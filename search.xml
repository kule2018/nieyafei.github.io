<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6之Set、WeakSet、Map、WeakMap数据结构]]></title>
    <url>%2F2018%2F03%2F13%2Fes6%2Fes-5%2F</url>
    <content type="text"><![CDATA[Set set本身是一个构造函数，用来生成Set数据结构，类似数组Array，但是成员的值都是唯一的，没有重复的值 属性方法 size: 返回set实例的成员总数 add(value): 添加某个值，返回Set本身 delete(value): 删除某个值，返回是否删除成功的boolean has(value): 判断是否包含某个值，返回一个boolean clear(): 清空Set的所有成员，没有返回值 123456# add方法let aSets = new Set();aSets.add(1);// 添加1aSets.add(2);// 添加2# 结果&#123; 1,2&#125; 另一种创建Set的方法1let bSet = new Set([1,2,3,4,5]); 如果添加重复的value值，会怎么样123aSets.add(2);结果：&#123;1,2&#125; 独一无二的 添加的数值类型，有什么区别123aSets.add(&apos;2&apos;);结果：&#123;1,2,&quot;2&quot;&#125; 1234# sizeaSets.size;// 结果： 2 123456# delete方法aSets.delete(1);结果：trueaSets.delete(3)#结果： false 123# has方法aSets.has(1);#结果：true 1234# clear方法aSets.clear();# aSets打印结果是&#123;&#125; 遍历对象 keys()：返回一个键名的遍历器 values(): 返回一个键值的遍历器 entries(): 返回一个键值对的遍历器 forEach(): 使用回调函数遍历每个成员 1234567891011121314151617181920212223242526# 创建一个Setlet list = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]);# keys()for(let key of list.keys())&#123; console.log(key); // a b c d&#125;# values()for(let value of list.values())&#123; console.log(value); // a b c d&#125;# entries()for(let [key,value] of list.entries())&#123; console.log(key,value); // a a b b c c d d&#125;# forEach()list.forEach(function(item)&#123; console.log(item); // a b c d&#125;) WeakSet 结构和Set类似，但是有写区别1、只能存储对象，其他类型的值不行2、存储的对象是弱引用，也就是说垃圾回收机制不考虑WeakSet对该对象的引用。换种说法如果一个对象都不再被引用，那么垃圾回收机制会自动回收该对象所占用的内存，不会考虑该对象是否存在于WeakSet中。因此WeakSet是不可遍历的 12# 新建一个WeakSetlet list = new WeakSet([&#123;a:1,b:2&#125;,&#123;c:3,d:4&#125;]); 属性方法 add(value)方法 delete(value)方法 has(value)方法 不支持clear、size方法如果增加其他类型的数值，则会报错12list.add(2);# Uncaught TypeError: Invalid value used in weak set Map 类似于对象，是键值对的集合，但是key的范围不局限与字符串。各种类型均可以作为key 属性方法 set(key,value): 添加一个键值对 get(key): 获取一个key对应的value值 size: 返回Map结构的成员总数 has(key)：判断某个键是否存在Map结构中，返回boolean delete(key)： 删除某个指定的键值，返回boolean clear(): 清除Map结构所有的成员 1234567# setlet map = new Map();map.set(&quot;1&quot;,&quot;a&quot;);map.set(&quot;2&quot;,&quot;b&quot;);map.set(&quot;3&quot;,&quot;c&quot;);或let map = new Map([[&quot;1&quot;,&quot;a&quot;],[&quot;2&quot;,&quot;b&quot;],[&quot;3&quot;,&quot;c&quot;]]); 12# deletemap.delete(&quot;1&quot;); 12# sizemap.size; 12# hasmap.has(1);// true 12#clearmap.clear(); 遍历方法 keys()：返回一个键名的遍历器 values(): 返回一个键值的遍历器 entries(): 返回一个键值对的遍历器 forEach(): 使用回调函数遍历Map每个成员 12345# keys()for(let key of map.keys())&#123; console.log(key); // 1 2 3&#125; 12345# values()for(let value of map.values())&#123; console.log(value); // a b c&#125; 1234# entries()for(let [key,value] of map.entries())&#123; console.log(key,value);&#125; 1234# forEach()map.forEach(function(value,key)&#123; console.log(value,key);&#125;) WeakMap 和Map类似，区别就是键只能是object类型键名是对象的弱引用，因此所对应的对象可能会被自动回收，如果对象呗回收后，WeakMap自动移除对应的键值对，WeakSet有助于防止内存泄露 属性方法 get(key) set(key,value) has(key) delete(key) 123456let map = new WeakMap();map.set(&#123;a:&quot;1&quot;&#125;,&quot;a&quot;);map.set(&#123;b:&quot;2&quot;&#125;,&quot;b&quot;);map.set(&#123;c:&quot;3&quot;&#125;,&quot;c&quot;);或let map = new WeakMap([[&#123;a:&quot;1&quot;&#125;,&quot;a&quot;],[&#123;b:&quot;2&quot;&#125;,&quot;b&quot;],[&#123;c:&quot;3&quot;&#125;,&quot;c&quot;]]); WeakMap其他的方法使用基本和Map一样，在这不多说了 弱集合、内存与垃圾回收 Map和Set中对象的引用都是强类型化的，并不会允许垃圾回收, 如果Map和Set中引用了大型对象（不再被使用），ps: 已经从DOM树中删除的DOM元素，那么其回收代价是昂贵的 从上面可以知道，ES6提供的WeakMap和WeakSet的弱集合，这些集合之所以是“弱的”，是因为它们允许从内存中清除不再需要的被这些集合所引用的对象 更多详情&gt;&gt;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之box-shadow]]></title>
    <url>%2F2018%2F03%2F07%2Fcss%2Fcss3-box-shadow%2F</url>
    <content type="text"><![CDATA[前言 box-shadow: h-shadow v-shadow blur spread color inset; 参数值 描述 h-shadow (X轴偏移量) 必需。水平阴影的位置。允许负值。 v-shadow (Y轴偏移量) 必需。垂直阴影的位置。允许负值。 blur (阴影模糊半径) 可选。模糊距离。 spread (阴影扩展半径) 可选。阴影的尺寸。 color (阴影颜色) 可选。阴影的颜色。请参阅 CSS 颜色值。 inset (投影方式) 可选。将外部阴影 (outset) 改为内部阴影。 文档来自=&gt;W3Cschool Step – 实例讲解Step-1：1box-shadow: 0 0 5px #ccc;// x，y偏移量为0 5px的模糊半径 Step-2：12# 改变X轴偏移量box-shadow: 5px 0 5px #ccc;// 水平偏移5px Step-3：12# 改变Y轴偏移量box-shadow: 0 5px 5px #ccc;// 垂直偏移5px Step-4：12# 改变X、Y轴偏移量box-shadow: 3px 5px 5px #ccc; Step-5：1234# 改变X、Y轴偏移量,可以为负值box-shadow: -3px -5px 5px #ccc;box-shadow: -3px 5px 5px #ccc;box-shadow: 3px -5px 5px #ccc; Step-6：1234# 设置insetbox-shadow: -3px -5px 5px #ccc inset;box-shadow: -3px 5px 5px #ccc inset;box-shadow: 3px -5px 5px #ccc inset; Step-7：注意：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。 1box-shadow:-3px -5px 5px blue inset,3px 5px 5px red,3px 5px 5px green inset,-3px -5px 5px black; Step-8：12345678910111213#Demo的实例#html&lt;div class=&quot;main&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829#cssbody,html&#123;background: #fafafb;&#125; *&#123;padding: 0;margin: 0;&#125;ul li&#123;list-style: none;&#125;.main&#123;padding: 100px 0&#125;.main ul&#123; width: 1200px; margin: 0 auto;&#125;.main ul li &#123; width: 360px;background: #fff;height: 360px;line-height:360px;display: block;float: left;margin-bottom: 60px;text-align: center;font-size: 100px; color: #ccc; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; transition: all .4s; -webkit-transition: all .4s; -moz-transition: all .4s;&#125;.main ul li:nth-child(3n+2)&#123; margin-left:60px;margin-right:60px;&#125;.main ul li:hover&#123; box-shadow: 1px 4px 10px 2px #ccc; -webkit-box-shadow: 1px 4px 10px 2px #ccc; -moz-box-shadow: 1px 4px 10px 2px #ccc; transform: translateY(-2%);&#125; Demo地址在线操作 原文blog：http://codehtml.cn]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之寄生组合式继承（六）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto6%2F</url>
    <content type="text"><![CDATA[通过借用构造函数来击沉属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型的构造函数，我们只是需要一个超类型的副本。实际上是来继承超类型的原型，然后将结果指定给子类型的原型。 基本模式 12345678910function inheritPrototype(subType,superType)&#123; // 创建一个超类的副本 var prototype = Object.create(superType.prototype); // 为副本添加构造函数指向 prototype.constructor = subType; // 将副本赋值给子类的原型 subType.prototype = prototype;&#125; 创建一个超类函数 12345678unction Car(color)&#123; this.color = color; this.colorArray = [&quot;黑色&quot;,&quot;白色&quot;,&quot;红色&quot;,&quot;蓝色&quot;]&#125;Car.prototype.getMessage = function()&#123; console.log(this.color);&#125; 创建一个子类函数 1234function Audi(color,year)&#123; Car.call(this,color); this.year = year;&#125; 使用寄生继承 1inheritPrototype(Audi,Car); 123Audi.prototype.sayYear = function()&#123; console.log(this.year);&#125; 实例继承测试123var car1 = new Audi(&quot;黑色&quot;,&quot;2015&quot;);car1.sayYear(); // 2015console.log(car1.colorArray);// [ &apos;黑色&apos;, &apos;白色&apos;, &apos;红色&apos;, &apos;蓝色&apos; ]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之寄生式继承（五）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto5%2F</url>
    <content type="text"><![CDATA[寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有的工作一样返回对象 1234567function createAnothor(o)&#123; var clone = Object.create(o); clone.getMessage = function()&#123; console.log(&quot;hi&quot;); &#125; return clone;&#125; 实例继承测试 1234567var car = &#123; master: &quot;master&quot;, color: &quot;黑色&quot;&#125;var car1 = createAnothor(car);car1.getMessage();// hi 寄生式继承也是一种有用的模式 注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，与构造函数模式类似]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之原型式继承（四）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto4%2F</url>
    <content type="text"><![CDATA[借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型 12345function object(o)&#123; function F()&#123;&#125; // 临时性的构造函数 F.prototype = o; return new F();&#125; 创建一个对象 12345var car = &#123; master: &quot;car1Master&quot;, color: &quot;黑色&quot;, colorArray:[&quot;黑色&quot;,&quot;白色&quot;,&quot;红色&quot;,&quot;蓝色&quot;]&#125; 通过object方法原型式继承 1234567891011121314var car1 = object(car);car1.color = &quot;白色&quot;;console.log(car1.color);car1.colorArray.push(&quot;棕色&quot;);# 结果：白色var car2 = object(car);car2.color = &quot;红色&quot;;car2.colorArray.push(&quot;灰色&quot;);console.log(car2.color);console.log(car1.colorArray);console.log(car2.colorArray);# 结果：红色# 结果：[ &apos;黑色&apos;, &apos;白色&apos;, &apos;红色&apos;, &apos;蓝色&apos;, &apos;棕色&apos;, &apos;灰色&apos; ] ECMAScript5新增了Object.create()方法规范了原型式继承，接收两个参数：一个用作新对象原型的对象，二是为新对象定义额外属性的对象 123456789var car1 = Object.create(car);car1.color = &quot;白色&quot;;car1.colorArray.push(&quot;棕色&quot;);console.log(car1.color);var car2 = Object.create(car);car2.color = &quot;红色&quot;;car2.colorArray.push(&quot;灰色&quot;);console.log(car2.color); Object.defineProperties：以指定的任何属性覆盖原型对象上的同名属性12345678var car3 = Object.create(car,&#123; color: &#123; value: &quot;绿色&quot; &#125;&#125;)console.log(car3.color);// 结果：绿色]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之组合继承（三）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto3%2F</url>
    <content type="text"><![CDATA[组合继承也叫伪经典继承，也就是组合了原型链和借用构造函数实现思想：使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承，这样不仅可以在原型上定义方法，又能保证每个实例都有它自己的属性 创建超类构造函数Car 12345678function Car(master,color)&#123; this.master = master; this.color = color;&#125;# 原型链方法Car.prototype.changeColor = function(color)&#123; this.color = color;&#125; 创建子类构造函数Audi 1234function Audi(master,color,year)&#123; Car.call(this,master,color);// 继承 this.year = year;// 购买年份&#125; 原型链继承以及构造函数指向设置（重点） 12Audi.prototype = new Car();Audi.prototype.constructor = Audi;// 设置原型的构造函数指向 子类构造函数设置原型链方法 123Audi.prototype.getMessage = function()&#123; return this.master + &quot;在&quot; + this.year + &quot;年买了一辆&quot;+this.color+&quot;的奥迪&quot;;&#125; 实例继承测试 12345678var car1 = new Audi(&quot;car1Master&quot;,&quot;黑色&quot;,&quot;2016&quot;);var car2 = new Audi(&quot;car2Master&quot;,&quot;白色&quot;,&quot;2017&quot;);console.log(car1.getMessage());// 结果：car1Master在2016年买了一辆黑色的奥迪console.log(car2.getMessage());// 结果：car2Master在2017年买了一辆白色的奥迪 使用超类构造函数的方法12345678car1.changeColor(&quot;红色&quot;);car2.changeColor(&quot;蓝色&quot;);console.log(car1.getMessage());// 结果：car1Master在2016年买了一辆红色的奥迪console.log(car2.getMessage());// 结果：car2Master在2017年买了一辆蓝色的奥迪]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之构造函数继承（二）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto2%2F</url>
    <content type="text"><![CDATA[构造函数继承也就是也用构造函数，也可以说是伪造对象或经典继承思想很简单：在子类型构造函数的内部调用超类型构造函数 创建构造函数 12345678function Car(master,color)&#123; this.master = master; this.color = color;&#125;# 创建原型链方法Car.prototype.changeColor = function(color)&#123; this.color = color;&#125; 创建Audi子构造函数，并且继承Car构造函数 123function Audi()&#123; Car.apply(this,arguments);&#125; 创建Audi原型链方法 123Audi.prototype.getMessage = function()&#123; return this.master + &quot;有一辆&quot;+this.color+&quot;的奥迪&quot;;&#125; 实例继承测试 1234567var car1 = new Audi(&quot;car1Master&quot;,&quot;黑色&quot;);var car2 = new Audi(&quot;car2Master&quot;,&quot;白色&quot;);console.log(car1.getMessage());// 结果：car1Master有一辆黑色的奥迪console.log(car2.getMessage());// 结果：car2Master有一辆白色的奥迪 注意：Car超类构造函数的原型有一个changeColor方法，Audi继承了Car,那么对于Audi来说，原型的方法是不可见的，因此函数的复用就无从谈起了 好处：对于原型链继承来说，构造函数继承可以向超类构造函数中传递参数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript继承之原型链继承（一）]]></title>
    <url>%2F2018%2F02%2F04%2Fjs%2Fjs-proto1%2F</url>
    <content type="text"><![CDATA[基本思想是利用原型链继承另一个引用类型的属性和方法 创建Car构造函数 12345678function Car()&#123; this.color = &quot;黑色&quot;;// 汽车基础颜色&#125;Car.prototype.changeColor = function(otherColor)&#123; // 提供更换颜色方法 this.color = otherColor;&#125; 创建Audi构造函数 123function Audi(master)&#123; this.master = master;&#125; Audi原型链继承Car 1Audi.prototype = new Car(); 创建Audi原型链方法 123456Audi.prototype.getColor = function()&#123; return this.color;&#125;Audi.prototype.getMessage = function()&#123; return this.master+&quot;的奥迪颜色是&quot;+this.color;&#125; 实例继承测试 123var car1 = new Audi(&quot;老王&quot;);console.log(car1.getColor());// 黑色console.log(car1.getMessage());// 老王的奥迪颜色是黑色 验证原型和实例之间的关系 第一种instanceof 123console.log(car1 instanceof Object);// trueconsole.log(car1 instanceof Car);// trueconsole.log(car1 instanceof Audi);// true 第二种isPrototypeOf 123console.log(Object.prototype.isPrototypeOf(car1));// trueconsole.log(Car.prototype.isPrototypeOf(car1));// trueconsole.log(Audi.prototype.isPrototypeOf(car1));// true 通过原型链实现继承时，不能使用对象字面量创建原型方法！！！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5新标签dialog]]></title>
    <url>%2F2018%2F01%2F22%2Fhtml%2Fhtml-dialog%2F</url>
    <content type="text"><![CDATA[HTMl5新的版本出现了一个有意思的标签，是我比较中意的，那就是对话窗或窗口，也就是dialog 1234# 基本用法&lt;dialog open&gt; // somthing ...&lt;/dialog&gt; open：规定 dialog 元素是活动的，用户可与之交互。表示这个对话框可以进行互动. 兼容性(本篇文章使用chrome测试) HTMLDialogElement close() 关闭对话框。 可选传入类型为{domxref(“DOMString”)}}的参数，用来更新对话框的returnValue。摘自MDN open() 非模式化的显示这个对话框, 即：打开这个对话框之后依然可以和其他内容进行交互。 可选传入类型为 Element 或者 MouseEvent 的参数，用来定义对话框的显示位置。摘自MDN showModal() 模式化的显示这个对话框， 并且将会至于所有其他对话框的顶层（屏蔽其他对话框的交互）。 可选传入类型为Element 或者 MouseEvent 的参数， 用来定义对话框的显示位置。摘自MDN 来做一个demo玩玩吧 1234567# 创建一个dialog&lt;dialog&gt; &lt;h1&gt;我是一级标题&lt;/h1&gt; &lt;div&gt;我是对话窗口，你已经打开了我！&lt;/div&gt; &lt;button id=&quot;close_dialog&quot;&gt;关闭&lt;/button&gt;&lt;/dialog&gt;&lt;button id=&quot;open_dialog&quot;&gt;打开&lt;/button&gt; 123456789101112# js代码&lt;script&gt; var dialog = document.getElementsByTagName(&quot;dialog&quot;)[0], openDialog = document.getElementById(&quot;open_dialog&quot;), closeDialog = document.getElementById(&quot;close_dialog&quot;); openDialog.onclick = function()&#123; dialog.showModal();// 或者show(),这是有区别的 &#125; closeDialog.onclick = function()&#123; dialog.close(); &#125;&lt;/script&gt; show()和showModal() 是有区别的，show只是显示dialog,而showMadal()是会屏蔽其他的弹出层 按ESC可以关闭dialog，dialog需要重新定义css样式，毕竟本身css是默认的样式我们先来看看dialog的元素默认样式：123456789101112131415161718192021222324252627dialog:not([open]) &#123; // 显示的时候 display: none;&#125;dialog &#123; display: block; position: absolute; left: 0px; right: 0px; width: -webkit-fit-content; height: -webkit-fit-content; color: black; margin: auto; border-width: initial; border-style: solid; border-color: initial; border-image: initial; padding: 1em; background: white;&#125;dialog::backdrop &#123; position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; background: rgba(0, 0, 0, 0.1);&#125; 1234# 重置背景色dialog::backdrop&#123; background-color: rgba(0, 0, 0, 0.6) &#125; Demo MDN链接： Dialog HTMLDialogElement]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript立即执行函数]]></title>
    <url>%2F2018%2F01%2F19%2Fjs%2Fiife%2F</url>
    <content type="text"><![CDATA[立即执行函数–IIFE (Immediately Invokable Function Expressions》 IIFE是我们经常遇到的，IIFE是在函数声明后立即调用的函数表达式，也就是大家说的闭包 123456789# 两种写法模式(function()&#123; consoloe.log(&quot;我是打印君&quot;);&#125;)()(function()&#123; console.log(&quot;我是打印君！&quot;)&#125;())# 结果：我是打印君 这样写的好处有哪些呢？1、不需要为函数命名，执行完成之后就自动销毁了，防止了污染全局变量2、闭包会形成单独的作用域 也是可以传参数的，具体代码如下12345(function(str)&#123; console.log(str)&#125;)(&quot;我是打印君！&quot;)# 结果：我是打印君 在其他的情况下，我也会看到在function前面加! + -运算符，这些运算符都将函数声明转成函数表达式，javascript引擎会识别，并且是立即执行的函数 123!function()&#123; console.log(&quot;我是打印君！&quot;)&#125;() 123+function()&#123; console.log(&quot;我是打印君！&quot;)&#125;() 123-function()&#123; console.log(&quot;我是打印君！&quot;)&#125;()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas绘制三角形和圆形]]></title>
    <url>%2F2017%2F12%2F14%2Fcanvas%2Fcanvas-demo1%2F</url>
    <content type="text"><![CDATA[绘制填充三角形 1234567// 填充三角形ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(50,150);ctx.lineTo(150,150);ctx.fillStyle = &apos;red&apos;;// 填充颜色ctx.fill(); 123456789// 描边三角形ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(50,150);ctx.lineTo(150,150);ctx.closePath();ctx.strokeStyle = &quot;#0000FF&quot;;// 线条颜色ctx.stroke(); 绘制圆形之前，先看一下下面这个图 原文链接：Canvas arc() 画一个整个圆 12345// 绘制圆形ctx.beginPath();ctx.arc(200,200,50,0,Math.PI*2,true);ctx.strokeStyle = &quot;#4ACAD9&quot;;ctx.stroke(); 画一个半圆 1ctx.arc(200,200,50,0,Math.PI*1,true); 画一个四分之一的圆弧 123ctx.arc(200,200,50,0,Math.PI*1.5,true);ctx.moveTo(350,150);ctx.arc(300,150,50,0,Math.PI*0.5,false); 画一个四分之三的圆弧123ctx.arc(200,200,50,0,Math.PI*1.5,false);ctx.moveTo(380,200)ctx.arc(330,200,50,0,Math.PI*0.5,true) 如果把生成改成fill来填充的话，则会变成这样 123456ctx.beginPath();ctx.arc(200,200,50,0,Math.PI*1.5,true);ctx.moveTo(380,200);ctx.arc(330,200,50,0,Math.PI*0.5,false)ctx.fillStyle = &quot;#4ACAD9&quot;;ctx.fill();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-变量、作用域和内存问题]]></title>
    <url>%2F2017%2F09%2F21%2Fjsh%2Fjsh2%2F</url>
    <content type="text"><![CDATA[基本类型和引用类型的值 变量可能包含两种不同数据类型的值：基本数据类型（Undefined,Null,String,Number,Boolean）和引用数据类型（Object） 将一个值赋给对象时，解析器必须确定这个值是基本数据类型值还是引用数据类型值 动态属性 创建对象并且给对象赋值 123var num = new Object();num.name=&quot;aaa&quot;;console.log(num.name); 复制变量值 如果复制一个基本类型的值，则在变量对象上创建一个心智，然后把该值复制到新的变量位置上 12var a = &quot;aaa&quot;;var b = a;// 虽然a和b的值是一样的，但是值是完全独立的，这两个变量可以参与任何操作而不受影响 如果复制一个引用类型的变量，也会将储存在变量中的值复制一份到新的变量的储存空间上，但是这个值的副本其实是一个指针，而这个指针指向存储在堆中的一个变量 12345var obj = new Object();var obj2 = obj;obj.name = &quot;liLy&quot;;console.log(obj2.name);// liLy 传递参数 所有函数的参数都是按值传递的，也就是说函数外部的值复制给函数内部的参数， 123456var count = 20;function sum(num)&#123;num +=10;return num;&#125;sum(count);// count：20 结果是30 12345678910function setName(obj, name) &#123;obj.name = name;&#125;var person = new Object();var person2 = new Object();setName(person, &quot;lily&quot;);setName(person2, &quot;lily2&quot;);console.log(person, person2);// &#123; name: &apos;lily&apos; &#125; &#123; name: &apos;lily2&apos; &#125; 检测类型 typeof 操作符是确定变量是字符串，数字，布尔值还是undefined的最佳工具，如果变量是一个对象或者null或者数组，则typeof会返回Object对于引用类型的检测，提供了instanceof操作符 1234567891011var person = new Object();console.log(typeof(person));// objectconsole.log(person instanceof Object);// truevar person2 = [1, 2, 3];console.log(typeof(person2));// objectconsole.log(person2 instanceof Object);// truevar person3 = null;console.log(typeof(person3));// objectconsole.log(person3 instanceof Object);// false 1234567var person2 = [1, 2, 3];console.log(typeof(person2))；// objectconsole.log(person2 instanceof Array);// true 这是一个数组var person3 = new RegExp();console.log(typeof(person3));// objectconsole.log(person3 instanceof RegExp);// true 正则表达式 执行环境及作用域 执行环境定义了变量或函数有权访问的其他数据，决定了各自的行为每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中 全局执行环境是最外围的一个执行环境，在web浏览器中，全局执行环境被认为是window对象 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。函数执行之后，栈将其环境弹出，控制权返回给之前的执行环境。当代码在一个环境中执行是，会创建变量对象的一个 一个作用域链，保证对执行环境的有权访问所有变量和函数的有序访问。如果这个环境是函数，则将其 活动对象作为变量对象。活动对象最开始只包含一个变量arguments(全局对象不存在) 12345678910111213var color = &quot;blue&quot;;// 全局变量function changeColor() &#123;// 在此可以调用全局变量，并且更改其值if (color === &quot;blue&quot;) &#123;color = &quot;black&quot;;&#125; else &#123;color = &quot;red&quot;;&#125;var temColor = &quot;#333&quot;;// 外部无法调取此变量&#125;changeColor(); 延长作用域链 try-catch语句的catch语块：会创建一个新的对象with语句：会将指定的对象添加到作用域链中这两个语句都会在作用域链前端添加一个变量对象 1234567891011121314var localObj = &#123;name: &quot;前端蜗牛&quot;,size: 25&#125;function getName() &#123;var start = &quot;我是&quot;,start2 = &quot;今年&quot;;with(localObj) &#123;var totalName = start + name + start2 + size;&#125;return totalName;&#125;console.log(getName());// 我是前端蜗牛今年25 没有块级作用域 123456# if语句中的变量声明会将变量添加到当前的执行环境if (true) &#123;var col = &quot;nihao&quot;;&#125;console.log(col);// nihao 声明变量 使用var来声明变量，会自动添加到最接近的环境中。在函数内部，最接近的环境就是函数内部环境with语句中，最接近的环境是函数环境如果初始化时没有使用var声明，该变量就会被自动添加到全局环境 查询标识符 在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么，搜索过程中从作用链前端开始，向上逐级查询与给定的名字匹配的标识符，如果局部环境找到该标识符，则搜索停止，如果没有找到该变量名，则沿作用域链向上搜索，一直追溯到全局环境的变量对象，如果全局环境中没有找到，说明为定义该变量 垃圾收集 javascript有自动垃圾收集机制 标记清除 引用次数 性能问题 管理内存]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-基本函数]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-6%2F</url>
    <content type="text"><![CDATA[函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行使用关键词 function来声明 1234function foo(name,size)&#123; console.log(&quot;打印&quot;)&#125;foo(&quot;lily&quot;,18);// 调用函数 1234function sum(num1,num2)&#123; return num1+num2;&#125;var total = sum(2,5);// 7 严格模式对函数有一定的限制 不能把函数命名为 eval 或 arguments 不能把参数命名为 eval 或 arguments 不能出现两个命名参数同名的情况 arguments1234567function Foo()&#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]); console.log(arguments.length);// 参数个数&#125;Foo(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);// aaa bbb ccc 严格模式情况下，函数内部arguments禁止修改 ECMAScript函数不能像传统意义上那样实现重载如果定义了两个名字相同的函数，则名字只属于后定义的函数]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-语句]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-5%2F</url>
    <content type="text"><![CDATA[if语句 if(condition) statement1 else statement2 do-while语句 一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件在对条件表达是求值之前，循环体内的代码至少会被执行一次 123456789var i = 9;do &#123; console.log(i++);&#125; while (i &lt; 11);// 9 10var i = 9;do &#123; console.log(i++);&#125; while (i &lt; 9);// 9 while语句 前测试循环语句，在循环体执行之后，就会对出口条件求值 123456789var i = 9;while (i &lt; 11) &#123; console.log(i++);&#125;// 9 10var i = 9;while (i &lt; 9) &#123; console.log(i++);&#125;// 不打印 for语句 前测试循环语句，但它具有在执行循环之前初始化变量和定义变量循环后要执行的代码能力 1234567for(var i=0;i&lt;20;i&lt;&lt;)&#123; //other&#125;for(;;)&#123; 无限循环&#125; for-in语句 精准的迭代语句，用来枚举对象的属性for(property in expression) statement 123for (var pName in window) &#123; console.log(&quot;123456&quot;)&#125; label语句 可以在代码中添加标签，以便将来使用 12345label: statementstart: function(;;)&#123; // other&#125; breack 和 continue 语句 用于在循环中精确地控制代码的执行break:立即退出循环，强制继续执行循环后面的语句continue:立即退出循环，但是退出循环之后会从循环的顶部继续执行 1234567# break语句for (var i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125;&#125;console.log(i);// 5 1234567# continue语句for (var i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; continue; &#125; console.log(i);// 1 2 3 4 6 7 8 9&#125; 12345678910111213141516# label语句的结合start: for (var i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break start; &#125; &#125;console.log(i)start: for (var i = 1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; continue start; &#125; console.log(i) &#125; with语句 将代码的作用域设置到一个特定的对象中严格模式不支持此语法 switch语句 语句在比较值时使用的是全等操作符，因此不会发生类型转换 1234567891011121314151617181920212223function sw(i) &#123; switch (i) &#123; case 1: console.log(1) break; case 2: console.log(2); break; case 3: //合并两种情况 case 4: console.log(&quot;公用&quot;); break; default: console.log(&quot;默认&quot;) &#125;&#125;sw(1);// 1sw(2);// 2sw(3);// 公用sw(3);// 公用sw();// 默认]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-操作符]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-4%2F</url>
    <content type="text"><![CDATA[用于操作数据值的操作符，包括基本操作符，位操作符，关系操作符和相等操作符 一元操作符 只能操作一个值的操作符叫做一元操作符 递增递减操作符 分为前置和后置型 123456789var age = 20;age ++;++age;age = age + 1;var age = 20;age --;--age;age = age - 1; 执行前置递增递减操作的时候，变量的值都是在语句被要求之前以前改变的-被称为副效应 123var age = 20;var sie = ++age + 2;console.log(age,sie);// 21 23 执行后置递增递减操作的时候，变量的值是包含他们的语句之后执行的 12345var age = 20;var sie = age++ + 2;console.log(age,sie);// 21 22先执行age+2，然后执行age++ 一元加和减操作符123var num = 25;num = +num;// 25num = -num;// -25 位操作符 用于在基本的层次上，即是按照内存中表示数值的位来操作数值对于特殊的NaN和Infinity值操作时，都会被处理成0 数值的转换过程：64位的数值先被转换为32位的数值，然后将32位转换回64位数值 按位非（NOT） 1234567var age = 20;var sie = ~age;console.log(age,sie);// 20 -21等同于var age = 20;var sie = -age - 1;console.log(age,sie);// 20 -21 按位与（AND） 12var age = 26 &amp; 3;console.log(age);// 2 按位或（OR） 12var age = 26 | 3;console.log(age);// 27 按位异或（XOR） 12var age = 26 ^ 3;console.log(age); 25 左移(&lt;&lt;) 12var age = 2;var si = age &lt;&lt; 5;// 左移5位 有序号的右移(&gt;&gt;) 12var age = 64 &gt;&gt; 5;console.log(age);// 2 无序号的右移(&gt;&gt;&gt;) 123var age = 64 &gt;&gt;&gt; 5;console.log(age);// 2console.log(-64 &gt;&gt;&gt; 5);// 134217726 布尔操作符 布尔操作符一共有三个：非（NOT）、与（AND）和或（OR） 逻辑非（!） 逻辑非操作符遵循以下规则：如果操作符数是一个对象，返回false如果操作数是一个空字符串，返回true如果操作数是一个非空字符串，返回false如果操作数的数值是0，返回true如果操作数是null,返回true如果操作数是NaN，返回true如果操作数是undefined,返回true 逻辑与（&amp;&amp;） 1var flag = true &amp;&amp; false; 如果有一个操作数不是布尔值 如果第一个操作数是对象，则返回第二个操作数如果第二个操作数是对象，则只有在第一个操作数的结果是true的情况下才会返回该对象如果两个操作数是对象，则返回第二个操作数如果第一个操作数是null,则返回null如果第一个操作数是NaN,则返回NaN如果第一个操作数是undefined,则返回undefined 逻辑或（||） 1var result = true || false; 如果有个操作数不是布尔值 如果第一个操作数是对象，则返回第一个操作数如果第一个操作数的求值结果为false,则返回第二个操作数如果两个操作数是对象，则返回第一个操作数如果两个操作数是null,则返回null如果两个操作数是NaN,则返回NaN如果两个操作数是undefined,则返回undefined 乘性操作符 乘法、除法和求模操作符 乘法1var age = 12 * 10;// 乘法，计算两个数值的乘积 乘法操作符的规则：正正得正，正负相乘得负，负负相乘得正，超出ECMAScript限制的范围，则返回Infinity和-Infinty如果有一个操作符是NaN，则结果是NaN如果Infinity与0相乘，则结果是NaN如果是Infinity与非0数值相乘，结果是Infinity或-Infinity,取决于有符号操作数的符号如果Infinity和Infinity相乘，则结果也是Infinity如果有一个操作数不是整数，则会调用Number()将其转换为数值，然后再应用规则 除法 由一个斜线负号（/）表示，执行第二个操作符除一个操作符的计算 1var size = 66 / 3; 除法的规则：执行常规的除法运算，两个整数和两个负数相除结果都是正数，如果只有一个负数，则结果为负数超过ECMAScript范围的话，则返回Infinity或-Infinity如果有一个是NaN，则结果是NaN如果是Infinity被Infinity除，则结果是NaN如果是零被零除，则结果是NaN如果是非零的有限数被零除，则结果是Infinity或-Infinity,取决于有符号操作数的符号如果是Infinity被任何非零数除，怎结果是Infinity或-Infinity如果有一个操作数不是数值，则会执行Number转换之后，在执行上述规则 求模（余数 %） 1var s = 26 % 5;// 1 求模的规则：如果操作数都是数值，执行常规的除法计算，返回除得的余数如果被除数是无穷大值而除数是有限大的数值，则结果是NaN如果被除数是有限大的数值而除数的是零，则结果是NaN如果Infinity被Infinity除，则结果是NaN如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数如果被除数是0，则结果是0如果有一个操作数不是数值，则在后台调用Number()转换数值之后在执行操作 加行操作符 加法 加法的规则：如果有一个操作符是NaN,则结果是NaN如果是 Infinity 加 Infinity，则结果是Infinity如果是 -Infinity 加-infinity ，则结果是-Infinity如果是 Infinity 加 -infinity ，则结果是NaN如果是 +0 加 +0 则结果是+0如果是 +0 加 -0 则结果是+0如果是 -0 + -0 则结果是-0如果有一个操作数是字符串 如果两个操作符都是字符串，则拼接 如果有一个是字符串，则数值转成字符串拼接 减法 减法的规则：两个操作是数值，则正常进行减法运算如果有一个是NaN,则结果是是NaNInfinity - Infinity = NaN-Infinity 减 -Infinity = NaNInfinity 减 -Infinity ,则结果是Infinity-Infinity 减 Infinity, 则结果是-Infinity+0 减 +0 ，结果是+0-0 减 +0，则结果是-0-0 减 -0 ，则结果是+0如果有一个操作符是字符串，布尔值，null或undefined,则NUmber()转换之后，再进行减法运算如果一个操作符是对象，则调用对象的valueOf方法表示该对象的数值 关系操作符 小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=） 如果两个操作数的都是数值，则执行数值比较如果两个操作数是字符串，则比较两个字符串对应的字符编码值如果一个操作数是数值，则另一个操作数转换成数值，然后进行比较如果一个操作数是对象，则调用对象的 valueof(),然后进行比较，如果没有valueOf，则调用toString方法，然后进行比较如果一个操作数是布尔值，则先转换成数值，然后进行比较 相等操作符 相等和不相等：先转换再比较全等和不等：仅比较而不转换 相等（==）和不等（！=） 操作符规则：如果一个操作数是布尔值，则在比较相等性之前先转换为数值，false:0 true:1如果一个操作数是字符串，另一个操作数是数值，先将字符串转换为数值，然后比较如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法null 和 undefined 是相等的比较相等性之前，null 和 undefined不能转换为其他任何值如果有一个操作符是NaN,相等则返回false如果两个操作符是对象，则比较是不是同一个对象 全等（===）和不全等（！==） 和相等不等很像，但是比较的是同一类型的值 条件操作符 var max = (num1&gt;num2)?”true”:”false” 赋值操作符 (=) 作用就是把右侧的值赋给左侧的变量 123var num = 10;num = num + 20;num += 20; 算术操作符 乘/赋值（*=） 除/赋值（/=） 模/赋值（%=） 加/赋值（+=） 减/赋值（-=） 左移/赋值（&lt;&lt;=） 有符号的右移（&gt;&gt;=） 无符号的右移（&gt;&gt;&gt;=） 逗号操作符1234var num,num2,num3=10;赋值返回最后一个值var num = (2,10,5,2,0);// 0]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-基本数据类型]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-3%2F</url>
    <content type="text"><![CDATA[Undefined、String、Number、Null、Boolean、Object Undefined类型 只有一个值，那就是特殊的undefined如果声明的变量定义但是未对其初始化值，那么这个变量的值就是undefined 1234var mess;var menn = undefined;console.log(mess === undefined);// trueconsole.log(menn === undefined);// true ECMAScript第3版引入这个值，为了区分空对象指针和未经初始化的变量 对于未声明的变量，可以使用typeof检测数据类型 123456var mess;console.log(typeof mess);// undefinedconsole.log(typeof menn);// undefined对于`typeof`的判断，声明未定义的变量和未声明过的变量都返回了`undefined`值从上面可以看出，虽然未声明的变量也赋值了`undefined`,但是如果使用也会报错的 Null类型 是第二个只有一个值的数据类型，特殊的值是Null表示一个空对象指针，这也是为什么typeof 检测null时会返回object的原因 12var mess = null;console.log(typeof mess);// object 如果准备定义一个变量来保存对象，那么初始化的变量最好是null,这样，只需要检测是否为null即可 123456var mess = null;if (mess != null) &#123; console.log(&quot;不是null&quot;)&#125; else &#123; console.log(&quot;是null&quot;)&#125;// 是null undefined值是派生自null值，因此判断相等性是true 12console.log(null == undefined);// trueconsole.log(null === undefined);// 注意：false Boolean类型 使用最多的一种类型，有两个值，分别是true和falseBoolean类型的字面值true和false，也是区分大小写的，True和False都不是Boolean值，只是标识符 任何的数据类型都可以调用Boolean12var str = &quot;hello word&quot;console.log(Boolean(str));// true 下面是各个数据类型对于的转换规则： 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”空字符串 Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined n/a undefined Number类型 此类型用来表示整数和浮点数值（双精度数值）最基本的数值格式是十进制数 123456var num = 55;var num1 = 070;// 八进制的56八进制在严格模式下是无效的，会导致支持该模式 js 引擎抛出错误var str = 0xA;// 16进制console.log(str);// 10 浮点数值 所谓的浮点数值，就是值里面包括一个小数点，小数点后面必须至少有一位数字 1var num = 10.123;// 浮点数值 浮点数值需要的内存空间是保存整数值的两倍，但是遇到一些特殊的浮点值，ECMAScript会将这些特殊的浮点值转为整数值 12var num = 1.;// 1var num1 = 10.0;// 10 数值范围 由于内存的限制，ECMAScript并不能保存世界上所有的数值Number.MIN_VALUE：最小的数值，这个值是5e-324;Number.MAX_VALUE：最大的数值，1.7976931348623157e+308 如果计算超出范围，则会自动转换成特殊的 Infinity 值 NaN 非数值（Not a Number）是一个特殊的数值，表示一个本来要返回数值的操作数未返回数值的情况。 123# 特点：1、任何涉及NaN操作都会返回NaN;(NaN/10)2、NaN与任何值都不相等，包括自己本身 判断是否为数值的方法是isNaN(),true:不是数值，false:是数值 12345console.log(isNaN(&quot;aaa&quot;));// trueconsole.log(isNaN(&quot;2&quot;));// falseconsole.log(isNaN(&quot;2.3&quot;));// falseconsole.log(isNaN(NaN));// trueconsole.log(isNaN(true));// false 布尔值true被转换成数值1 数值转换 Number():任何数据类型都可以使用转换规则如下： 如果是Boolean值，true和false会被转成1和0如果是数字值，只是简单的传入和返回如果是null,返回0如果是undefined,返回NaN如果是字符串，则需要以下规则：1、字符串只包括数字（包括前面带正号和负号的情况），则进行十进制数值转换2、如果包含有效的浮点格式，则会转成对于的浮点数值。3、如果字符串包括有效的十六进制格式，则转换为相同大小的十进制整数值4、如果字符串是空的，则会转换成05、如果字符串包括上述以外的字符，则将其转换为0如果是对象，则调用对象的 valueOf() 方法，然后依照规则转换返回值，如果转换的结果是NaN，则调用toString() 的方法，然后依次按照前面的规则进行转换 parseInt()：专门用于字符串转换数值，看其是否符合数值模式 他会忽略字符串前面的空格，直到找到第一个非空格的字符如果第一字符不是数字字符或者负号，则会返回NaN如果第一个字符是数字字符或者负号，会继续解析第二个字符，直到所有后续字符或者遇到非数字字符 12console.log(parseInt(&quot;&quot;));// NaNconsole.log(parseInt(&quot;123456blue&quot;));// 123456 也可以是吧各种整数格式（八进制、十进制、十六进制） 1234console.log(parseInt(&quot;10&quot;, 2));// 2 按照2进制解析console.log(parseInt(&quot;10&quot;, 8));// 8 按照8进制解析console.log(parseInt(&quot;10&quot;, 10));// 10 按照10进制解析console.log(parseInt(&quot;AF&quot;, 16));// 175 按照16进制解析 parseFloat()：专门用于字符串转换数值 和parseInt()相似，但是只解析十进制，所以没有第二个参数，始终都会忽略前导的0 String类型 表示由多个或者零个16位Unicode字符组成的字符序列，即字符串，字符串可用于双引号或单引号表示 字符字面量 转义序列，用于表示非打印字符，或者具有其他用途的字符 字面量 含义 \n 换行 \t 制表 \b 退格 \r 回车 \f 进纸 \\ 斜杠 \’ 单引号，在单引号表示的字符串中使用 \” 双引号，再用双引号表示的字符串使用 \xnn 以十六进制代码nn表示一个字符（其中n为0-F） \unnn 以十进制代码nnn表示的一个Unicode字符（其中n为0-F） 字符串特点 ECMAScript中的字符串不可变的，字符串一旦创建，值就不能改变，如果想改变，首先要销毁原来的字符串，然后用另外一个包含新值得字符串填充该变量 转换为字符串 toString()方法：数值，布尔值，对象和字符串值都有此方法，但是Undefined,Null没有这个方法 String()方法：能够将任何值进行转换为字符串 如果值有toString()方法，则调用该方法（没有参数），并返回相应的结果 如果是null,则返回“null” 如果值是undefined,怎返回“undefined” Object类型 一组数据和功能的集合，对象可以通过new操作符后跟要穿甲的对象类型的名称来创建var o = new Object(); Object属性和方法 constructor：保存着用于创建当前对象的函数，构造函数（constructor）就是Object() hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是实例的原型中）是否存在，其中，作为参数的属性名（propertyName）必须以字符串形式指定 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够通过for-in语句来枚举，与hasOwnProperty()方法一样，作为参数的属性名必须以字符串的形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应 toString()：返回对象的字符串表示 valueOf()：返回对象的字符串、数值或布尔值表示。通常和toString()方法返回相同]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-基本概念]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-2%2F</url>
    <content type="text"><![CDATA[区分大小写 ECMAScript的一切，包括变量、函数名、操作符都要区分大小写 1var test 和 var Test 这是两个不同的变量 标识符 标识符是指变量、函数名、属性的名字，或者函数的参数。 标识符的规则： 1、第一个字符必须是一个字母、下划线（_）或一个美元符号（$）2、其他的字符可以是字母、下划线、数字、美元符号 ps:按照惯例，标识符采用驼峰大小格式 注释 单行注释1//这是单行注释 多行注释1234/** 我是多行注释* 我是注释*/ 语句 解析中以一个分号结尾，如果省略分号，则由解析器确定语句的结尾，建议不要忽略分号 关键字和保留字 具有一定的用途的关键字，关键字可用于表示控制语句的开始或结束，或执行特定的操作 关键字有哪些12345break do instanceof typeof in trycase else new var catchfinally return void continue forswitch while debugger function thiswith default if throw delete 保留字有哪些1234567891011121314151617abstract enum int shortboolean export interface staticbyte extends long superchar final native synchronizedclass float package throwsconst goto private transientdebugger implements protected volatiledouble import public第5 版把在非严格模式下运行时的保留字缩减为下列这些：class enum extends superconst export import在严格模式下，第5 版还对以下保留字施加了限制：implements package public interfaceprivate static let protectedyield 变量 变量是松散型的，可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值得占位符 12var message;// 这是一个变量，未经过初始化，变量的值为`undefined`var i = 2; 数据类型 基本数据类型 Undefined、String、Number、Null、Boolean、Object typeof 操作符 一种用来验证给定变量的数据类型的手段 undefined:如果这个值未定义boolena:如果这个值是布尔值string:如果这个值是字符串number:如果这个值是数值object：如果这个值是函数function:如果这个值是函数 12var message = &quot;something&quot;;console.log(typeof message);]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红皮书读记-严格模式]]></title>
    <url>%2F2017%2F09%2F20%2Fjsh%2Fjsh1-1%2F</url>
    <content type="text"><![CDATA[严格模式(use strict) “use strict”; // 即在严格的条件下运行。 严格模式是在ECMAScript5新增的，严格模式下你不能使用未声明的变量，体现了Javascript更合理、更安全、更严谨的发展方向。 严格模式是为js定义了一种不同的解析和执行模型，在此模式下，对于ECMAScript3种的一些不确定行为将会处理，对于不安全的操作也会抛出错误的。一般都是在js的顶部添加此模式代码。 非严格的模式，也会被称为“马虎模式/稀松模式/懒散模式” 严格模式的好处 1、消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;2、消除代码运行的一些不安全之处，保证代码运行的安全;3、提高编译器效率，增加运行速度；4、为未来新版本的Javascript做好铺垫。 严格模式的调用开启 针对整个脚本文件的调用 在整个脚本文件最开始的地方引入，整个脚本都将以”严格模式”运行 12345678&lt;script&gt; &quot;use strict&quot;; console.log(&quot;这是严格模式。&quot;);&lt;/script&gt;&lt;script&gt; console.log(&quot;这是正常模式。&quot;);&lt;/script&gt;// 第一个是严格模式，第二个则是正常模式 单个函数的严格模式 声明在函数体的首行 1234function foo() &#123; &quot;use strict&quot;; console.log(&quot;函数严格模式执行&quot;);&#125; 脚本文件的变通写法 因为多个文件的合并不利于严格模式的声明，因此对第二种方法进行改造,将整个脚本文件放在一个立即执行的匿名函数之中。 1234(function ()&#123; &quot;use strict&quot;; // do someing&#125;)(); 严格模式和正常模式的区别 1、严格模式下你不能使用未声明的变量，必须先声明再使用 12345678&quot;use strict&quot;;x = 5;// ReferenceError: x is not defined或&quot;use strict&quot;;x = &#123;a: 1&#125;;// ReferenceError: x is not defined正常模式中，如果一个变量没有声明就赋值，默认是全局变量 2、不能删除变量或对象 1234&quot;use strict&quot;;var i = 1;delete i;// 删除变量// SyntaxError: Delete of an unqualified identifier in strict mode. 只有configurable设置为true的对象属性，才能被删除。configurable：能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true 12345678910&quot;use strict&quot;;var i = 1;var j = Object.create(null, &#123; &quot;i&quot;: &#123; value: 1, configurable: true &#125;&#125;)console.log(delete j.i);// true 3、禁止使用with语句 Javascript语言的一个特点，就是允许”动态绑定“，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 1234&quot;use strict&quot;;var i = 1;with(0) &#123; i = 2;&#125;SyntaxError: Strict mode code may not include a with statement with语句：由于大量使用with语句会导致性能下降，也会给调试代码造成困难，因此不建议使用with语句。with语句所引起的问题是块内的任何名称可以映射(map)到with传进来的对象的属性, 也可以映射到包围这个块的作用域内的变量(甚至是全局变量), 这一切都是在运行时决定的: 在代码运行之前是无法得知的. 严格模式下, 使用 with 会引起语法错误, 所以就不会存在 with 块内的变量在运行是才决定引用到哪里的情况了 创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。12345678910# 严格模式&quot;use strict&quot;;var i = 1;var j = eval(&quot;var i = 5; i&quot;);console.log(i, j);// 1 5# 正常模式var i = 1;var j = eval(&quot;var i = 5; i&quot;);console.log(i, j);// 5 5 4、禁止this关键字指向全局对象 123456789101112# 正常模式function foo() &#123; return !this;&#125;console.log(foo());// false 此时this指向全局对象# 严格模式function foo() &#123; &quot;use strict&quot; return !this;&#125;console.log(foo());// true 此时this的值为undefined 5、禁止在函数内部遍历调用栈 1234567function foo() &#123; &quot;use strict&quot; foo.caller; foo.arguments;//&#125;console.log(foo());// TypeError: &apos;caller&apos; and &apos;arguments&apos; are restricted function properties and cannot be accessed in this context. 6、不允许对只读属性赋值 writable：对象属性是否可修改,flase为不可修改，默认值为true 12345678&quot;use strict&quot;;var obj = &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123; value: 0, writable: false&#125;);obj.x = 3;// TypeError: Cannot assign to read only property &apos;x&apos; of object &apos;#&lt;Object&gt;&apos; 7、不允许删除一个不允许删除的属性 12&quot;use strict&quot;;delete Object.prototype; // 报错 8、不允许变量重名 123456&quot;use strict&quot;;function foo(p, p) &#123; console.log(&quot;不允许变量重名&quot;)&#125;foo(1, 2);// SyntaxError: Duplicate parameter name not allowed in this context 9、禁止八进制表示法 123&quot;use strict&quot;;var i = 0100;// SyntaxError: Octal literals are not allowed in strict mode. 10、不允许使用转义字符 123&quot;use strict&quot;;var x = \010;// SyntaxError: Invalid or unexpected token 11、不允许对arguments赋值 123456&quot;use strict&quot;;arguments++; // 语法错误var obj = &#123;set p(arguments) &#123;&#125;&#125;; // 语法错误try &#123;&#125; catch (arguments) &#123;&#125; // 语法错误function arguments() &#123;&#125; // 语法错误var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 17;&quot;); // 语法错误 12、arguments不再追踪参数的变化 123456&quot;use strict&quot;;function foo(a) &#123; a = 2; console.log(a, arguments[0]);&#125;foo(1);//2 1 如果是正常模式，则结果是2 2 13、禁止使用arguments.callee 123456# 无法在匿名函数内部调用自身了&quot;use strict&quot;; var f = function() &#123; return arguments.callee;&#125;; f();// TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to them 14、保留关键字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字，禁止用关键字声明变量:implementsinterfaceletpackageprivateprotectedpublicstaticyieldECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的 备注： 主流浏览器现在实现了严格模式。但是不要盲目的依赖它，因为市场上仍然有大量的浏览器版本只部分支持严格模式或者根本就不支持（比如IE10之前的版本）。严格模式改变了语义。依赖这些改变可能会导致没有实现严格模式的浏览器中出现问题或者错误。谨慎地使用严格模式，通过检测相关代码的功能保证严格模式不出问题。最后，记得在支持或者不支持严格模式的浏览器中测试你的代码。如果你只在不支持严格模式的浏览器中测试，那么在支持的浏览器中就很有可能出问题，反之亦然。 引用参考文章：严格模式-MDN严格模式-阮一峰]]></content>
      <categories>
        <category>javascript高级设计程序</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javascript高级设计程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6标准入门》读记之数组的扩展]]></title>
    <url>%2F2017%2F09%2F16%2Fes6%2Fes6-4%2F</url>
    <content type="text"><![CDATA[Array.from() 将两类对象转为数组1、类似数组的对象2、可遍历的对象（iterable）,包括数据结构的Set和Map 123456789var obj = &#123;&quot;0&quot;:&quot;aaa&quot;,&quot;1&quot;:&quot;bbb&quot;,&quot;2&quot;:&quot;ccc&quot;,length:3&#125;# ES5的写法console.log([].slice.call(obj))# ES6写法console.log(Array.from(obj));// 结果 [ &apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos; ] 实际应用中，常见的类似的数组对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。1234var pArr = document.querySelectorAll(&quot;p&quot;);Array.from(pArr).forEach(function(p)&#123; console.log(p)&#125;) Array.of() 用于将一组值转换为数组Array方法没有参数和有一个参数或三个参数时，返回的结果不一样 12345678910# Array()console.log(Array());// []console.log(Array(3));// [,,]console.log(Array(3,4,5,6));//[3,4,5,6]#Array.of()console.log(Array.of());//[]console.log(Array.of(3));//[3]console.log(Array.of(3,4,5,6));// 结果 [ 3, 4, 5, 6 ] 12345Array.of()等同于function ArrayOf()&#123; return [].slice.call(arguments)&#125;console.log(ArrayOf(1,2,3)) copyWithin() 在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有成员）这个方法会修改当前数组 Array.prototype.copyWithin(target,start=0,end = this.length)target（必需）:从该位置开始替换数据start（可选）:从该位置开始读取数据，默认0；如果为负数，则倒数end (可选)：到该位置停止读取数据，默认等于数据的长度。如果是负数，表示倒数 12345console.log([1,2,3,4,5].copyWithin(0,2));// [ 3, 4, 5, 4, 5 ]console.log([1,2,3,4,5].copyWithin(0,2,4));// [ 3, 4, 3, 4, 5 ] find()和findIndex() find找出第一个符合条件的数组成员findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合，则返回-1 find方法可以接受三个参数第一个参数是当前的值第二个参数是当前的位置第三个参数是原数组 1234567891011121314console.log([1,2,3,4,5,6,7].find((n)=&gt; n&gt;5));// 结果 6[1,2,3,4,5,6,7].find(function(value,index,arr)&#123; return value&gt;6&#125;)[1,2,3,4,5,6,7].findIndex(function(value,index,arr)&#123; return value&gt;6&#125;);// 7console.log([1,2,3,4,5,6,7].findIndex(function(value,index,arr)&#123; return value&gt;6&#125;));// 6 #fill() 给定值填充数据用于空数组的初始化还可以接受第二个和第三个参数，用于指定的起始位置和结束位置 12console.log(new Array(10).fill(true));// [ true, true, true, true, true, true, true, true, true, true ] entries()、keys()、values() entries对键值对的遍历keys 对键名的遍历values 对键值得遍历 1234# keysfor(let index of [1,2,3,4].keys())&#123; console.log(index)&#125; 1234# valuesfor(let value of [1,2,3,4].values())&#123; console.log(index)&#125; 1234# entriesfor(let [index,value] of [1,2,3,4].entries())&#123; console.log(index)&#125; includes() 表示某个数组是否包含给定的值 1console.log([1,2,3,4,5].includes(2));// true]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6标准入门》读记之字符串的扩展]]></title>
    <url>%2F2017%2F09%2F16%2Fes6%2Fes6-3%2F</url>
    <content type="text"><![CDATA[字符的Unicode表示 js允许采用\uxxxx形式表示一个字符，xxxx表示字符的码点Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。ES6增强了对Unicode的支持 关于Unicode，详情点击:UnicodeUnicode 的表示局限于\u0000-\uFFFF之间的字符123console.log(&quot;\u0061&quot;);// a&quot;\u8717\u725b&quot;则代表的是蜗牛如果超过范围的字符，必须用2个双字节的形式表达 ES6对此做出了改进，只要将码点放入大括号，就能正确读取该字符1234console.log(&quot;\u&#123;41&#125;&quot;);// Aconsole.log(&quot;\u1F680&quot;);// Ὠ0console.log(&quot;\u&#123;1F680&#125;&quot; === &quot;\uD83D\uDE80&quot;);//true codePointAt() 能正确处理4个字节存储的字符，返回一个字符的码点返回的码点是十进制值，如果想返回十六进制的值，可以使用toString转换 12345678910111213var s = &quot;吉利&quot;;# 十进制console.log(s.codePointAt());//21513#十六进制console.log(s.codePointAt().toString(16));// 5409# 遍历var s = &quot;吉利&quot;;for(let cn of s)&#123; console.log(cn.codePointAt(0).toString(16))&#125;// 5409 5229 判断一个字符由2个字节还是4个字节组成12var s = &quot;吉&quot;;console.log(s.codePointAt(0) &gt; 0XFFFF);//false String.fromCodePoint() 此方法用于从码点返回对于的字符不能识别32位的UTF-16字符（Unicode编号大于0xFFFF） 1console.log(String.fromCodePoint(0x20BB7));// 𠮷 字符串的遍历接口（for of） 可以识别大于0XFFFF的码点，传统的for循环无法识别 123for(let a of &quot;蜗牛&quot;)&#123; console.log(a)&#125; 123for(let a of String.fromCodePoint(0x20BB7))&#123; console.log(a)&#125; at()和charAt() ES5的charAt()返回字符串给定位置的字符charAt()该方法不能识别码点大于0xFFFF的字符 12console.log(&quot;abc&quot;.charAt(0));// aconsole.log(&quot;𠮷&quot;.charAt(0)); ES7提供的at()，存在兼容问题12console.log(&quot;abc&quot;.at(0))console.log(&quot;𠮷&quot;.at(0)) normalize() 用来将字符的不同表示方法统一为同样的形式，也就是Unicode正规化 includes() 返回boolean值，表示是否找到了参数字符串支持第二个参数，表示搜索的位置 12console.log(&quot;abcd&quot;.includes(&quot;a&quot;));// trueconsole.log(&quot;abcd&quot;.includes(&quot;a&quot;,1));// false startsWith() 返回boolean值，表示参数字符串是否在源字符串的头部支持第二个参数，表示搜索的位置 12console.log(&quot;abcd&quot;.startsWith(&quot;a&quot;));// trueconsole.log(&quot;abcad&quot;.startsWith(&quot;a&quot;,3));// true endsWith() 返回boolean值,表示参数字符串是否在源字符串的尾部支持第二个参数，表示搜索的位置，前n个字符 12console.log(&quot;abcd&quot;.endsWith(&quot;a&quot;));// falseconsole.log(&quot;abcdc&quot;.endsWith(&quot;c&quot;,3));// true repeat() 返回一个新的字符串，表示将源字符串重复n次 12console.log(&quot;12&quot;.repeat(10));// 12121212121212121212 如果生成一个10个相同值(12)的数组1234var str = &quot;12,&quot;.repeat(10).split(&quot;,&quot;);str.pop();console.log(str);// [ &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos;, &apos;12&apos; ] padStart()和padEnd() 如果某个字符串未达指定长度，会在头部或尾部补全padStart用于头部补全，padEnd用于尾部补全 12console.log(&quot;a&quot;.padStart(6,&quot;nihao&quot;));// nihaoaconsole.log(&quot;a&quot;.padStart(5,&quot;nihao&quot;));// nihaa 12console.log(&quot;a&quot;.padEnd(5,&quot;nihao&quot;));// anihaconsole.log(&quot;a&quot;.padEnd(10,&quot;nihao&quot;));// anihaoniha 模板字符串js正常的字符串12var b = &quot;bbb&quot;;var a = &quot;aaa&quot;+&quot;&lt;div&gt;&quot;+b+&quot;&lt;/div&gt;&quot;; 这样的写法比较繁琐，特别是多行的字符串,es6提供了增强版，用反引号(`)标识，可以作为普通字符串使用，也可以定义多行字符串，或者字符串中嵌入变量123456var name = &quot;蜗牛&quot;;var teh = `demonihaohello $&#123;name&#125;`;console.log(teh); String.raw() 此方法用来充当模板字符串的处理函数，返回一个被转义的字符串，对应于替换变量后的模板字符串]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6标准入门》读记之变量的解构赋值]]></title>
    <url>%2F2017%2F09%2F12%2Fes6%2Fes6-2%2F</url>
    <content type="text"><![CDATA[数组的解构赋值 ES6允许按照一定的语法，从数组或者对象中取值，然后对变量进行赋值 模式匹配赋值 等号两边的模式相同，左边的变量就会被赋予对应的值 解构赋值适用于var let const 命令 123456# 正常的赋值var a = 1,b=2,c=3;# ES6的赋值let [a,b,c] = [1,2,3];console.log(a,b,c);// 打印结果1 2 3这种就是模式匹配 1234567891011# 嵌套的数组的赋值let [a,b,[c]] = [1,2,[3]];console.log(a,b,c);// 打印结果 1 2 3# 留空的数组赋值let [a,,[c]] = [1,2,[3]];console.log(a,c);// 打印结果 1 3# 不定参数(可变参数)赋值let [a,...c] = [1,2,3,&quot;aaa&quot;];console.log(a,c);// 1 [ 2, 3, &apos;aaa&apos; ] 如果解构不成功，变量的值就是undefined,这种被称为不完全解构不成功的情况有很多种，比如右侧的数组或对象和左侧的变量未成功匹配12let [a,...c] = [1];console.log(a,c);// 结果a=1 c=undefined 12let [a,...c] = [1];console.log(a,c);// 结果a=1 c=[] 解构赋值默认值123456let [a,b=&quot;bbb&quot;] = [&quot;aaa&quot;]console.log(a,b);// 结果 aaa bbb# ES6内部使用严格相等运算符`===`判断一个位置是否有值，如果不严格等于undefined,默认值是不会生效的let [a,b=&quot;bbb&quot;] = [&quot;aaa&quot;,null]console.log(a,b);// 结果 aaa null 如果是一个set的结构呢？那么我们也可以用数组的解构赋值12345678let [a,b,c] = new Set([&quot;aaa&quot;,&quot;bbb&quot;,&quot;vvv&quot;]);console.log(a,b,c);// 结果：aaa bbb vvvlet [a,c] = new Set([&quot;aaa&quot;,&quot;bbb&quot;,&quot;vvv&quot;]);console.log(a,c);// 结果：aaa bbblet [a,,c] = new Set([&quot;aaa&quot;,&quot;bbb&quot;,&quot;vvv&quot;]);console.log(a,c);// 结果：aaa vvv 只要某种数据结果具有Iterator(迭代器)接口,或者原生具有这个接口，都可以进行数组的解构赋值 那么什么是Iterator(迭代器)? 一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）在ES6中原生具备这个接口的：数组 类似数组的对象 Set Map 对象的解构赋值 对象的解构和数组的解构是有区别的，对象的解构赋值是没有次序的，而数组是有次序的对象的变量必须与属性同名，才能取得正确的值 变量名和属性名一致 12let &#123;a,c&#125; = &#123;a:&quot;aaa&quot;,b:&quot;bbb&quot;,c:&quot;ccc&quot;&#125;console.log(a,c);// 结果就是 a=&quot;aaa&quot;,c=&quot;ccc&quot; 那么如果变量名和属性名不一致怎么赋值？ 123let &#123;a,c&#125; = &#123;a1:&quot;aaa&quot;,b1:&quot;bbb&quot;,c1:&quot;ccc&quot;&#125;console.log(a,c);// 结果 undefined undefined# 无法取到值，so都是undefined 123# 正确写法let &#123;a1:a,c1:c&#125; = &#123;a1:&quot;aaa&quot;,b1:&quot;bbb&quot;,c1:&quot;ccc&quot;&#125;console.log(a,c);//结果 aaa ccc 通过上述的方法，其实是对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量，真正的赋值是后者还不是前者var {foo,baz}={foo:”111”,baz:”222”}等同于var {foo:foo,baz:baz}={foo:”111”,baz:”222”} 嵌套对象的解构123456789var obj = &#123; p:[ &quot;nihao&quot;, &#123;y:&quot;beijing&quot;&#125; ]&#125;var &#123;p:[x,&#123;y&#125;]&#125; = obj;console.log(x,y)//结果 nihao beijing# p 是模式 12345678910var obj = &#123; p:&#123; start:&#123; line:5 &#125; &#125;&#125;var &#123;p:&#123;start:&#123;line&#125;&#125;&#125; = obj;console.log(line)# p和start都是模式 字符串的解构赋值 字符串可以进行解构赋值，字符串会被转换成一个类似数组的对象 123# 简单的例子let [a,b,c] = &apos;hello&apos;;console.log(a,b,c);// h e l 123# 数组的对象都有length属性let &#123;length&#125; = &apos;hello&apos;;console.log(length);//5 数值和布尔值的解构赋值 在解构的时候，如果等号右边的是数值或布尔值，则会先转为对象 1234567# undefinedlet &#123;length&#125; = 123;console.log(length);数值和布尔值的包装对象都有toString属性let &#123;toString:s&#125; = 123;console.log(s === Number.prototype.toString);//true 函数参数的解构赋值1234function add([a,b])&#123; return a+b;&#125;add([1,2]);//3 1[[1,2],[5,6]].map(([a,b])=&gt; a+b)//结果是 [3,11] 解构赋值的用处 交换变量的值 12345let a = 3;let b = 5;[a,b] = [b,a];console.log(a,b);# 当然交换变量的值还有很多种方法 从函数返回多个值 12345function ex()&#123; return [1,2]&#125;let [a,b] = ex();console.log(a,b);//1 2 函数参数的定义 提取JSON数据 函数参数的默认值 遍历Map结构因为Map结构原生支持Iterator,因此可以使用for … of … 对map进行遍历，这样比较方便 1234567var map = new Map();map.set(&quot;1&quot;,&quot;aaa&quot;);map.set(&quot;2&quot;,&quot;bbb&quot;);for(let [key,value] of map)&#123; console.log(key+&quot;:&quot;+value);&#125;// 结果 1:aaa 2:bbb 输入模块的指定方法]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6标准入门》读记之常用变量]]></title>
    <url>%2F2017%2F09%2F12%2Fes6%2Fes6-1%2F</url>
    <content type="text"><![CDATA[ES5只有var和function这两种声明变量的方法ES6添加了let、const、import、class这四种方法，所以ES6有6种声明变量的方法 let和const使用 let：用于声明变量 虽然和var用法类似,但是有区别1、声明的变量只在其代码块有效，块级作用域2、不存在变量的提升（一定要先声明再使用）3、暂时性死区：如果let在块级作用域使用，那么声明的变量绑定此区域，不受外部影响，形成了封闭作用域4、不允许重复声明 let和var使用例子123456var a = &quot;aaa&quot;;function test()&#123; let b = &quot;bbbb&quot;;&#125;console.log(a,b);//报错：ReferenceError: b is not defined 123console.log(a,b); // 报错：ReferenceError: b is not definedvar a = &quot;a&quot;;let b = &quot;bbb&quot;; 下面用经典的面试例子来做一个例子1234567# 正常的for循环打印数据for(var i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125;# 结果:5 5 5 5 5 1234567# 使用let来循环一下看看for(let i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100)&#125;# 结果:0 1 2 3 4 123456789# 当然使用js闭包也可以for(var i=0;i&lt;5;i++)&#123; (function(m)&#123; setTimeout(function()&#123; console.log(m) &#125;,100) &#125;)(i)&#125;# 结果:0 1 2 3 4 关于块级作用域123456789# 声明变量function ff()&#123; var tem = new Date(); if(true)&#123; var tem = &quot;aaa&quot;; &#125; console.log(tem)&#125;ff()// 结果是aaa const：用于声明常量，一旦声明，其值不可改变 const的使用和let有些类似1、声明常量，不可更改2、作用域：只在声明所在的作用域有效3、和let一样声明变量不提升，存在短暂性死区，只能在声明之后使用4、不可重复声明变量 1234# 声明一个变量，然后修改这变量会有什么结果const AD = &quot;25639895&quot;;AD = &quot;aaaa&quot;;// TypeError: Assignment to constant variable. 1234567891011# 如果提前使用变量或者不在作用域使用，结果会报未定义console.log(AD)const tem = &quot;25639895&quot;;或function ff()&#123; const tem = &apos;aaa&apos;; console.log(&quot;第一次：&quot;+tem)&#125;console.log(&quot;第二次：&quot;+tem)ff()// 结果：ReferenceError: tem is not defined const声明一个复合类型对象，变量名不指向数据，而是指向数据所在的地址，这样只能保证地址不变，不能保证数据不变；123456const arr = [];arr[0] = &quot;aaa&quot;;console.log(arr)// [&apos;aaa&apos;]如果我修改一下arr = [&quot;aaa&quot;];//相当于重新赋值// 结果就会报 TypeError: Assignment to constant variable 如果我现在有一个对象{a:1,b:2,c:3},我不想改变这里面的值，应该怎么办？那么我们就需要将这个对象冻结Object.freeze()123456789# 不冻结的情况const arr = &#123;a:1,b:2,c:3&#125;arr.a = &quot;aaa&quot;console.log(arr.a)// 结果是aaa#冻结的情况const arr = Object.freeze(&#123;a:1,b:2,c:3&#125;)arr.a = &quot;aaa&quot;console.log(arr.a)// 结果是1]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端优化之图片优化]]></title>
    <url>%2F2017%2F08%2F31%2Fwebyhimg%2F</url>
    <content type="text"><![CDATA[开发前端也有几年了，一直很忙，课下看书，或者做一些笔记，看看别人的见解，也会做一些笔记记录，有时间就来刷刷掘金，逛逛技术网站，尴尬的事情是自己没有认真的总结过一些笔记和知识点，发出来大家共同学习，最近也才开始做一些markdown，后续我会抽时间继续做这件事，有什么不对的知识点，麻烦大家指出批评，也算对自己的一个巩固。 很多的前端开发者都比较关心性能的优化的问题，今天主要讲一下图片优化的见解和总结，可能很多人都知道，对此比较精通的大神，可以看一下分享一下我没有总结到的知识点，那么开始整理一下图片优化的笔记吧 每个前端网站都有可能引入很多的图片来达到酷炫或者展示的效果，有人会问？为什么非要用图片，因为有些技术上达不到的效果展示，只能用图片来代替，比如淘宝天猫京东这些商城的酷炫的创意广告图当然我们也会用到很多的图标图片，图片越多请求次数越多，造成延迟的可能性也就越大 最开始的时候，前端的时候我都会把实现不了的效果切换成图片还有一些图标也会切成图片，这样就会降低前端页面展示的性能，增加页面资源HTTP的请求 总结优化的地方有几个地方： 1、降低图片的大小 首先我们目前常用的图片格式有png,gif,jpg等，png又分png24和png8,关于图片的的知识点，我给大家两个网址大家可以了解一下，对于图片格式讲的很详细http://www.cnblogs.com/xiangism/p/5311314.htmlhttp://www.cnblogs.com/pqjzxq/p/5749304.html 我们的目的是降低图片的大小kb，有很多方法可以做，压缩图片，选择更小kb的图片格式，以达到最优 好多人都推荐一个压缩图片的网站—智图：一个图片优化平台用起来很简单的 现在百度一下很多在线压缩图的在线网站，比如TinyPNG:一个压缩PNG的神站 2、选择适当的图片宽度尺寸（即响应式图片） 不管是pc还是移动端，都会有很多不同尺寸的图片，如果你做的是响应式网站和移动端的话，那么你就更需要考虑图片尺寸的选择问题了 移动端的屏幕分辨率和尺寸太多，所以就可能需要不同的尺寸加载不同尺寸的图片，这样就节省了网站的访问流量，以及页面渲染的效率先展示现在设备的分辨率等的图 如果想查看更多的话，就去devices 响应式图片方式有哪几种， 可以通过服务器图片资源配置命名规则来获取图片1ps：&lt;img src=&quot;bgimg-320.jpg&quot; /&gt;或&lt;img src=&quot;bgimg-480.jpg&quot; /&gt; 通过css定义来加载不同的背景bg图片123456@media only screen and (max-width : 480px) &#123; .img &#123;background-image: url(bg-480.jpg);&#125;&#125;@media only screen and (max-width : 360px) &#123; .img &#123;background-image: url(bg-360.jpg);&#125;&#125; Img的srcset和sizes的方法这两个img属性是html5的属性，有浏览器的兼容问题 123&lt;img class=&quot;img&quot; src=&quot;imgbg-320.jpg&quot; srcset=&quot;imgbg-320.jpg 320w, imgbg-360.jpg 360w, imgbg-480px.jpg 480w&quot; sizes=&quot;(max-width: 480px) 480px, 320px&quot;&gt; src:当设备不支持srcset，sizes属性时，使用这个图片srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点1sizes=&quot;[media query] [length], [media query] [length] ... &quot; 对于srcset和sizes，详解点击查看 picture标签实现通过媒体查询的方式，根据页面宽度（当然也可以添加其他参考项）加载不同图片，具体picture详情点击查看 12345&lt;picture&gt; &lt;source srcset=&quot;3.jpg&quot; media=&quot;(min-width: 320px)&quot;&gt; &lt;source srcset=&quot;2.jpg&quot; media=&quot;(min-width: 480px)&quot;&gt; &lt;img srcset=&quot;1.jpg&quot;&gt;&lt;/picture&gt; 3、减少HTTP的网络资源请求 CSSSprites(背景精灵图/雪碧图)一种网页图片应用处理方式，将一个页面涉及到的所有零星图片或者图标都包含到一张大图里面，这样就只需要加载这个一个图片，而不是很多个图片了，这样就减少了很多http的请求 如何制作精灵图？自己通过ps制作，或者UI设计师制作的过程中，做好这个精灵图，注意图片直接的间隔，以防css操作的时候出现显示的问题 怎么使用精灵图？利用CSS的background-image，background- repeat，background-position的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置详细查看CSSSprites css和css3制作简单的图标和动画（代替gif图片）随着技术的发展，css3可以实现的效果越来越多，比如箭头图标，三角形，梯形等图标，或者一些阴影效果，渐变的效果，所以可以用css制作一些简单的图标，而且具有多变性 1234567.sanjiaoxing &#123; width: 0; height: 0; border-top: 2em solid #000; border-right: 1.8rem solid transparent; border-left: 1.8rem solid transparent;&#125; SVG技术替换图片SVG 是使用 XML 来描述二维图形和绘图程序的语言,支持透明，缩放，动画什么是SVG？(摘自w3cschool)SVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用来定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失SVG 是万维网联盟的标准SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 html5 canvas绘画图形目前canvas应用很多，它可以使用脚本javascript来绘制各种图表、动画等点击查看更多html5 canvas 4、字体图库代替图标 随着技术的更新和浏览器的更新，字体图库去代替一些图标我认为还是极好的，使用字体图库你不仅可以改变大小，而且还可以改变颜色大家比较熟知的的字体图库有很多，这里就说一个吧，font-awesom,截图看看他的好处吧 有了他，根本不担心图标的问题了，很简单的使用，只需要引入之后，按照规则写html标签即可 其实咱们也可以自定义咱们的图标选择，毕竟有的图标库我们用不到这么多，因此咱们可以自定义咱们的字体图标库目前我认为毕竟好的就是 Iconfont ,最近的几个react项目，我都在使用这个来定制自己的一些图标库，用起来也很简单 1、搜索自己想要的图标 2、在搜索结果页找到自己想要的图标，然后加入购物车 3、找完自己的图标之后点开购物车，会有一个添加到项目，点击它，如果你有项目就可以选择，如果没有就创建一个项目，点击确定之后即可4、在个人中心找到自己的项目，选择方式之后，点击下载即可使用 使用方式在这里就不多说了，和font-awesom基本上差不多的 5、微信小程序怎么使用字体图标 直接引入字体也可以，但是要把字体文件放在服务器上，并且允许跨域的情况下，在css文件里面远程地址引入字体文件即可1234567@font-face &#123;font-family: &quot;iconfont&quot;; src: url(&apos;https//examle.com/font/iconfont.eot?t=1494498562077&apos;); /* IE9*/ src: url(&apos;https//examle.com/font/iconfont.eot?t=1494498562077#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;https//examle.com/font/iconfont.woff?t=1494498562077&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;https//examle.com/font/iconfont.ttf?t=1494498562077&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;https//examle.com/font/iconfont.svg?t=1494498562077#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; 如果不想放在服务器上，还有一种方法可以使用，这个时候我们需要一个工具来辅助一下 transfonter,将解压出来的ttf字体文件转化成base64格式 生成的文件里面替换css里面的代码123456@font-face &#123; font-family: &apos;iconfont&apos;; src: url(data:font/truetype;charset=utf-8;base64,这里省略了) format(&apos;truetype&apos;); font-weight: 500; font-style: normal;&#125; 使用和直接引入字体图标是一样的 还有一些优化的方式在上一篇文章已经列了，这里就不多说了，我还会持续更新,大家共同学习巩固一下 如有没有说到的地方，麻烦大家指出]]></content>
      <categories>
        <category>web架构</category>
      </categories>
      <tags>
        <tag>web架构</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端资源文件的部署和优化]]></title>
    <url>%2F2017%2F08%2F29%2Fwebzyyh%2F</url>
    <content type="text"><![CDATA[现在网上也有很多关于前端文件加载的性能优化，我相信大部分的前端程序猿，应该都听说过雅虎的14条优化原则12345678910111213141. 尽可能的减少 HTTP 的请求数 content2. 使用 CDN（Content Delivery Network） server3. 添加 Expires 头(或者 Cache-control ) server4. Gzip 组件 server5. 将 CSS 样式放在页面的上方 css6. 将脚本移动到底部（包括内联的） javascript7. 避免使用 CSS 中的 Expressions css8. 将 JavaScript 和 CSS 独立成外部文件 javascript css9. 减少 DNS 查询 content10. 压缩 JavaScript 和 CSS (包括内联的) javascript css11. 避免重定向 server12. 移除重复的脚本 javascript13. 配置实体标签（ETags） css14. 使 AJAX 缓存 有些人通过这14个规则总结了一下: 优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等 请求带宽 开启服务器GZip，精简JavaScript，移除重复脚本，图像优化（包括图片大小kb） 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 前端资源的优化今个主要说一下资源部署和优化的一些方案，也借鉴了好多人的理解和图来说一下 1、资源的预加载（prebrowsing） 预加载是浏览器对将来可能被使用资源的一种暗示，一些资源可以在当前页面使用到，一些可能在将来的某些页面中被使用。作为开发人员，我们比浏览器更加了解我们的应用，所以我们可以对我们的核心资源使用该技术。 我们可以使用该技术来预先告知浏览器某些资源可能在未来会被使用。 DNS 预解析dns-prefetch1234Head头部里面加入：&lt;link rel=&quot;dns-prefetch&quot;href=&quot;//example.com&quot;&gt;# 请求这个域名下的文件时就不需要等待DNS查询了,也就是说在浏览器请求资源时，DNS查询就已经准备好了# 该技术对使用第三方资源特别有用，比如jquery等 预连接 Preconnect12# 与 DNS 预解析类似，preconnect 不仅完成 DNS 预解析，同时还将进行 TCP 握手和建立传输层协议&lt;link rel=&quot;preconnect&quot; href=&quot;http://example.com&quot;&gt; 现代浏览器都试着预测网站将来需要哪些连接，然后预先建立 socket 连接，从而消除昂贵的 DNS 查找、TCP 握手和 TLS 往返开销。然而，浏览器还不够聪明，并不能准确预测每个网站的所有预链接目标。好在，在 Firefox 39+ 和 Chrome 46+ 中我们可以使用 preconnect 告诉浏览器我们需要进行哪些预连接。 预获取 Prefetching12# 顾名思义，提前加载资源（未用到），首先要确定这个资源一定会在未来用到，然后提前加载，放入浏览器缓存中&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt; prefetch很适用于优化webfonts的性能，但预获取还依赖于一些条件，某些预获取可能会被浏览器忽略，例如从一个非常缓慢的网络中获取一个庞大的字体文件。并且，Firefox 只会在浏览器闲置时进行资源预获取。 优先级Subresource这个也是预获取方式，只是不同的是，指定的预获取资源具有最高的优先级，在所有 prefetch 项之前进行 1&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt; 预渲染 Prerender12# Prerender 预先加载的资源文件，也就是说可以让浏览器提前加载指定页面的所有资源&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com/index.html&quot;&gt; 未来 Preload123# Preload 建议允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源&lt;link rel=&quot;preload&quot; href=&quot;http://example.com/image.png&quot;&gt;# 存在兼容性 以上是预加载的基本解释，详细查看详解文章 2、利用304本地缓存资源文件我们大家都知道，正常的网络请求的返回状态是200，如果我们每次访问页面之后，都要去加载，这样就会浪费带宽，影响页面的性能，那么我们现在就需要304来让浏览器使用本地缓存 HTTP 304 用户首次请求该文件的时候，通过HTTP HEAD的Last-Modified字段将该文件的最后修改日期发送到客户端，让客户端知道该文件的版本 浏览器再次请求该文件的时候，会自动将该时间作为请求的HTTP HEAD的If-Modified-Since字段内容 服务端根据If-Modified-Since字段的内容(如果存在该字段)来判断客户端的文件是否已经过期，如果已经过期，则重新返回新的文件，如果没有，则只需要返回304状态码，不需要返回文件内容。文件是否过期可以从Cache-Control设置max-age值，那么在此值内的时间里就不会重新访问服务器 对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新 对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。 如果想清除缓存文件，可以按CTRL-F5 (有时称之为“强刷-hard refresh”),这时候会发现浏览器省略了If-Modified-Since和If-None-Match请求头,也就是无条件的请求页面中的每个资源. 如果服务器资源更新了，前端还在使用缓存文件，如果想让页面更新缓存文件怎么办？不可能让用户自己去清除自己的缓存吧？下面我们来说一种缓存更新的文件 3、版本号更新资源文件123&lt;link href=&quot;./static/css/main.css?v=1.0.0&quot; rel=&quot;stylesheet&quot;&gt;或&lt;link href=&quot;./static/css/main.css?time=1245639&quot; rel=&quot;stylesheet&quot;&gt; 如果我们更新了main.css文件,那么只需要更改v=后面的版本号即可重新加载main.css资源文件，其实也可以用hash值来表示1&lt;link href=&quot;./static/css/main_88f0972.css&quot; rel=&quot;stylesheet&quot;&gt; 还有一种情况就是，如果我有n个文件，但是我只更新了其中一个文件，这个时候我不想其他的文件更新的话，那么我们就需要做到一点，只改变我要更新的文件的版本号或者其他的值即可更新此资源文件 4、CDN静态资源部署也就是说，把静态资源文件和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径 原理：不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。 不同地区的用户访问同一个域名却能得到不同CDN节点的IP地址，这要依赖于CDN服务商提供的智能域名解析服务，浏览器发起域名查询时，这种智能DNS服务会根据用户IP计算并返回离它最近的同网络CDN节点IP，引导浏览器与此节点建立连接以获取资源。 也有一些第三方的CDN: 前端公共库CDN加速 5、非覆盖式发布资源目前很多更新自由文件都是覆盖式的发布，但是覆盖式的发布会造成一些问题 用待发布资源覆盖已发布资源，无论是先上线页面，还是先上线静态资源都会在部署过程中发生页面错乱的问题。所以就需要非覆盖式发布，用文件的哈希值来对资源文件进行重命名，把哈希字符串放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件，这样用户在访问的时候就不会出现错乱的问题。 这种资源很多，不止css，包括js，图片路径，字体图标库等1&lt;link href=&quot;./static/css/main_88f0972.css&quot; rel=&quot;stylesheet&quot;&gt; 下面借鉴一个图来示例一下，很容易看懂： 这种方法虽然优化了资源文件，但是它无法通过手动来维护，需要一些工具来支持，推荐几个构建工具： FIS3 webpack gulp Yeoman 还有其他的就不说了，自己可以google一下,好多的内容我也是看了很多篇的讲资源优化的方案总结出来的，有不对的地方可以请批评指出]]></content>
      <categories>
        <category>web架构</category>
      </categories>
      <tags>
        <tag>web架构</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript两个变量互换值，你了解多少]]></title>
    <url>%2F2017%2F08%2F24%2Fjavascript-bl%2F</url>
    <content type="text"><![CDATA[javascript两个变量交换值这个问题看似很基础，但是有很多的实现方式，你知道的有多少呢，网上也有很多的方法，下面就来总结一下 中间变量（临时变量）12345678临时变量其实很好理解，通过一个中间变量进行交换值var strA = &quot;a&quot;;var strB = &quot;b&quot;;var strC;//中间变量# 开始strC = strB;//strC值是bstrB = strA;//此时strB已经变成strAstrA = strC;//让strA赋值strB的值 使用加减（针对数字）1234567891011var a=2,b=3;加法算：a +=b;//a=5,b=3b =a-b;//b=2a =a-b;//b=3减法算：a +=b;//a=5b = a-b;//b=2;a -=b;//a=3两种方法都需要两个值相加，然后做对于的加减算 对象和数组12345678910var a=&quot;1&quot;,b=&quot;2&quot;;对象的方法:先把a变成一个对象，即a=&#123;a:b,b:a&#125;b=a.a;//1a=a.b;//2数组的方法：数组其实和对象的思想差不多a=[a,b];b=a[0];a=b[1]; 万能法(运用运算符优先级)1234公式：a=[b,b=a][0]var a=&quot;1&quot;,b=&quot;code&quot;;a=[b,b=a][0];//这样就成功了console.log(a,b);//code 1 ES6的解构赋值 什么是解构赋值？ 解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。 123数组与迭代器的解构语法:[ variable1, variable2, ..., variableN ] = array;这将为variable1到variableN的变量赋予数组中相应元素项的值 可以去看看解构的赋值：http://es6.ruanyifeng.com/#docs/destructuring 123let a = &quot;one&quot;,b = &quot;two&quot;;[a, b] = [b, a];console.log(a, b);//two one 利用try catch交换12345678910111213141516var a=1,b=2;a=(function()&#123;; try&#123;return b&#125; finally&#123;b=a&#125;&#125;)();或字符串var a = &quot;aaa&quot;, b = &quot;bbb&quot;;a = (function() &#123;; try &#123; return b &#125; finally &#123; b = a &#125;&#125;)();console.log(a, b); 异或运算(针对数字)1234567891011121314151617181920var a = 1; // 二进制：0001var b = 2; // 二进制：0010a = a ^ b; // 计算结果：a = 0011, b = 0010b = a ^ b; // 计算结果：a = 0011, b = 0001a = a ^ b; // 计算结果：a = 0010, b = 0001自己可以动手试一下例子：var a = 0;var b = 1;a = (b = (a ^= b) ^ b) ^ a;console.log(a,b)例子：var a = 0; // 二进制：0001var b = 1; // 二进制：0010a ^=b;b ^=a;a ^=b;console.log(a,b) 数组的两个值的交换1234567var arr = [item0,item1,...,itemN];//最初使用这段代码来交换第0个和第K(k&lt;N)个元素arr[0] = arr.splice(k, 1, arr[0])[0];var arr = [1,2,3,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;];arr[0] = arr.splice(3, 1, arr[0])[0];console.log(arr.toString())//aaa,2,3,1,bbb,ccc]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之Array的使用]]></title>
    <url>%2F2017%2F08%2F23%2Fjsarray%2F</url>
    <content type="text"><![CDATA[Array数组对象是用于构造数组的全局对象; 它是高阶，类似列表的对象。我们可以创建一个数组123456789101112var array = new Array();var array = new Array(20);//数组的成员数量20或var array = new Array(20)var arrs = [&quot;1&quot;,&quot;2&quot;];arrs.length();//数组的长度#可以通过索引访问数组元素arrs[0]//结果1#创建一个空数组var arr = []; ###遍历一个数组(常用) forEach 方法 123456var arrs = [&quot;aaa&quot;,&quot;bbb&quot;];arrs.forEach(function (item, index, array) &#123; console.log(item, index); //aaa 0 //bbb 1&#125;); for( ; ; ){} 123for(var i=0;i&lt; arrs.length;i++)&#123; console.log(arrs[i]);&#125; for in 方法 123for(var i in arrs)&#123; console.log(arrs[i]);&#125; for of 方法 123for(var value of arrs)&#123; console.log(value);&#125; map() :方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 12345678910let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg])方法会将其传入三个参数，分别是`currentValue`当前成员、`index `当前位置和`array `数组本身var numbers = [1, 2, 3];numbers.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4] 如何判断是否为数组 1234var arr = [1,2,3];#判断方法typeof arr // &quot;object&quot;Array.isArray(arr) // true #Array实例方法 Array.from() :方法从一个类似数组或可迭代的对象中创建一个新的数组实例。12345678var arrs = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];Array.from(arrs);//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Array.from(&quot;welcome&quot;);//[ &apos;w&apos;, &apos;e&apos;, &apos;l&apos;, &apos;c&apos;, &apos;o&apos;, &apos;m&apos;, &apos;e&apos; ]Array.from(&quot;123456789&quot;)//[ &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;,&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos; ] 123456var setArr = new Set([&quot;sss&quot;,&quot;aaa&quot;])console.log(Array.from(setArr))//[ &apos;sss&apos;, &apos;aaa&apos; ]var mrr = new Map([[1, 2], [2, 4], [4, 8]]);Array.from(mrr);// [[1, 2], [2, 4], [4, 8]] 12345#from的functions方法Array.from([1, 2, 3], x =&gt; x + x);//[2, 4, 6]Array.from(&#123;length: 5&#125;, (v, i) =&gt; i);// [0, 1, 2, 3, 4] valueOf() :方法返回数组本身 12var arrs = [&quot;aaa&quot;,&quot;bbb&quot;];arrs.valueOf(); toString() :此方法返回数组的字符串形式 123456var arrs = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];arrs.toString();//&quot;a,b,c&quot;var arrs = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,[1,2,3]];console.log(arrs.toString())//a,b,c,1,2,3 Array.of() :方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined元素的数组。 12345Array.of(7); // [7]Array.of(1, 2, 3); // [1, 2, 3]# 对比Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] concat() :方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组 1234let arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];let arr2 = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;];let arr3 = arr1.concat(arr2);#结果[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;, &quot;e&quot;, &quot;f&quot;] copyWithin() :方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小 arr.copyWithin(target)arr.copyWithin(target, start)arr.copyWithin(target, start, end)arr.copyWithin(目标索引, [源开始索引], [结束源索引]) 123456789target0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。start0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。end0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。 1234567891011121314[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4][1, 2, 3, 4, 5].copyWithin(2, 1, 3)//[1,2,2,3,5] push() :方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 12345678910var numbers = [1, 2, 3];numbers.push(4);console.log(numbers);// [1, 2, 3, 4]#合并两个数组var a = [1,2,3,4];var b = [5,6];a.push.apply(a,b)//[1,2,3,4,5,6] pop() :方法用于删除数组的最后一个元素，并返回该元素。注意，此方法更改数组的长度，如果你在一个空数组上调用 pop()，它返回undefined 1234let a = [1, 2, 3];a.length; // 3#删除最后一个元素a.pop(); // 3 push和pop结合使用，就构成了“后进先出”的栈结构（stack） join() :方法将数组（或一个类数组对象）的所有元素连接到一个字符串中1234567891011let a = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];a.join();//默认为 &quot;,&quot;//&quot;1,2,3&quot;a.join(&quot;&quot;);// 分隔符 === 空字符串 &quot;&quot;// &quot;123&quot;a.join(&quot;-&quot;);//&quot;1-2-3&quot; 若数组成员存在undefined或null或空位，会被转成空字符串12345[undefined, null].join(&apos;-&apos;)// &apos;-&apos;[&apos;1&apos;,, &apos;2&apos;].join(&apos;-&apos;)// &apos;1--2&apos; 也可以通过call 方法用于字符串12345Array.prototype.join.call(&apos;hello&apos;, &apos;-&apos;)// &quot;h-e-l-l-o&quot;var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;;Array.prototype.join.call(obj, &apos;-&apos;)// &apos;a-b&apos; shift() :方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组 shift方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 length属性的值为 0 (长度为 0)，则返回undefined123let myFish = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;];myFish.shift();// [&apos;2&apos;, &apos;3&apos;, &apos;4&apos;] shift方法可以遍历并清空一个数组123456var list = [1, 2, 3];var ite;while (ite = list.shift()) &#123; console.log(ite);&#125;// 结果list:[] unshift() :方法将一个或多个元素添加到数组的开头，并返回新数组的长度 123let a = [1, 2, 3];a.unshift(4, 5);//添加// [4, 5, 1, 2, 3] reverse() :方法将数组中元素的位置颠倒 123var myArray = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];myArray.reverse();// [&apos;3&apos;, &apos;2&apos;, &apos;1&apos;] slice() :方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。 arr.slice();//[0,end]arr.slice(begin);//[begin,end]arr.slice(begin,end)://[begin,end)它的第一个参数begin为起始位置（从0开始），第二个参数end为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员 1234567var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.slice(1) // [&quot;b&quot;, &quot;c&quot;]arr.slice(1, 2) // [&quot;b&quot;]arr.slice(2, 7) // [&quot;c&quot;],7已经超过数组的lengtharr.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]如果是负数则表示倒数计算位置arr.slice(-2) // [&quot;b&quot;, &quot;c&quot;] slice方法的一个重要应用，是将类似数组的对象转为真正的数组1234567Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)// [&apos;a&apos;, &apos;b&apos;]或者function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3] splice() :方法通过删除现有元素和/或添加新元素来更改一个数组的内容 array.splice(start)array.splice(start, deleteCount)array.splice(start, deleteCount, item1, item2, …) 123splice:第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。# 起始位置如果是负数，就表示从倒数位置开始删除 123var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];arr.splice(4, 2) // arr:[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]arr.splice(4,2,1,2)//arr:[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;,1,2] sort() :方法在适当的位置对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点123var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];fruit.sort();// [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;] 12345var scores = [1, 10, 21, 2];scores.sort();// [1, 10, 2, 21]// 注意10在2之前,// 因为在 Unicode 指针顺序中&quot;10&quot;在&quot;2&quot;之前 12345var things = [&apos;word&apos;, &apos;Word&apos;, &apos;1 Word&apos;, &apos;2 Words&apos;];things.sort();// [&apos;1 Word&apos;, &apos;2 Words&apos;, &apos;Word&apos;, &apos;word&apos;]// 在Unicode中, 数字在大写字母之前,// 大写字母在小写字母之前. sort可以按照自定义的方式排序，可以传入一个函数作为参数1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] filter() :方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素,参数函数可以接受三个参数，第一个elem参数是当前数组成员的值，这是必需的，后两个参数是可选的，分别是当前数组成员的位置index和整个数组arr filter(function (elem, index, arr) {…do somthing…}) 12345function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);//[12, 130, 44] 1234[1, 2, 3, 4, 5].filter(function (item) &#123; return (item &gt; 4);&#125;)// [5] some() :方法测试数组中的某些元素是否通过由提供的函数实现的测试 12345const asd = (element, index, array) =&gt; &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(asd);//false[2, 5, 8, 1, 40].some(asd);//true every() :方法测试数组的所有元素是否都通过了指定函数的测试,类似some() reduce() :方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值 1234var total = [0, 1, 2, 3].reduce(function(item, value) &#123; return item + value;&#125;, 0);// total is 6 reduceRight() :方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值 1234let flattened = [[0, 1], [2, 3], [4, 5]].reduceRight((a, b) =&gt; &#123; return a.concat(b);&#125;, []);// flattened is [4, 5, 2, 3, 0, 1] indexOf(),lastIndexOf():indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1 123let a = [2, 9, 7, 8, 9];a.indexOf(2); // 0a.indexOf(6); // -1 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-112345var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1 find() :方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined 1234function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].find(isBigEnough); // 130 findIndex() :方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 1234function isBigEnough(element) &#123; return element &gt;= 15;&#125;[12, 5, 8, 130, 44].findIndex(isBigEnough); // 3 toLocaleString() :返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开 1234567var number = 1668;var date = new Date();var arr = [number, date, &quot;welcome&quot;];var str = arr.toLocaleString();console.log(str);// 输出 &quot;1,668,2017/8/15 下午8:32:24, welcome&quot;// 假定运行在中文（zh-CN）环境，北京时区 includes() :方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false arr.includes(searchElement)arr.includes(searchElement, fromIndex)searchElement需要查找的元素值fromIndex从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。 12345et a = [1, 2, 3];a.includes(2);// truea.includes(5);// false fill() :方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素 arr.fill(value)arr.fill(value, start)arr.fill(value, start, end)value用来填充数组元素的值 start起始索引，默认值为0 end 终止索引，默认值为 this.length 123var numbers = [1, 2, 3]numbers.fill(1);// results in [1, 1, 1]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass使用例子总结]]></title>
    <url>%2F2017%2F08%2F23%2Fsasssum%2F</url>
    <content type="text"><![CDATA[#简述这里就不介绍怎么安装sass了，很简单，去官网安装一下就行→Sass官网 我现在用最简单的一种方式写一个文件来描述函数的使用和方法（scss） 12#监听sass的改变sass --watch style.scss:css/style.css ###1、语法格式语法格式有两种，看个人喜好来写吧123456789101112131415161718#sass语法格式style.sass通过 tab 键控制缩进的一种语法规则，而且这种缩进要求非常严格$def-color: #333body font: 100% color: $def-color可能有的人不习惯sass这种写法#scss语法格式style.scss和正常的css差不多，代码都包裹在一对大括号里，并且末尾结束处都有一个分号$def-color: #333body&#123; font: 100%； color: $def-color；&#125; ###2、声明变量、引用变量12345678910#声明变量的符号“$”#变量名称(ps：them-color)#赋予变量的值(ps：14px/#333)$them-coklor:#843256;//默认主题色$btn-primary:$them-coklor !default;//按钮默认色值 ！default则表示默认值$border-color:#eee;#变量引用变量可以引用变量，上面的代码的$btn-primary引用了$them-coklor 123456789#ps：声明变量用的中划线进行分割（也可以用下划线）,中划线和下划线是互通，例子,#scss$color-lins:#242639;body&#123; color: $color_lins;&#125;#编译后的cssbody &#123; color: #242639; &#125; 父选择器的标识符&amp; 123456789101112131415161718192021#scssdiv a&#123; color: #333; &amp;:hover&#123; color: red; &#125; //如果body的class .ies body.ies &amp; &#123; color:#888; &#125;&#125;#编译后的cssdiv a &#123; color: #333;&#125;div a:hover &#123; color: red;&#125;body.ies div a &#123; color: #888;&#125; 普通变量和默认变量 123456789101112131415普通变量可以全局使用，默认变量则需要加上!defaultsass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。#scss$font-color:#f7f7f7;//普通变量$font-size:16px;//重新声明变量$font-size:14px !default;//默认变量.main&#123; color: $font-color; font-size: $font-size;&#125;#编译后的css.main &#123; color: #f7f7f7; font-size: 16px; &#125; 全局变量和局部变量 123456789101112131415161718192021222324252627#全局变量就是定义在元素外面的变量#scss$color:#333 !default;//全局变量h1&#123; color: $color;//引用全局变量 a&#123; $color:red;//重新定义变量，局部变量 span&#123; color: $color;//引用局部变量 &#125; &#125; $color:#999;//重新定义变量，局部变量 span&#123; color:$color;//引用局部变量 &#125;&#125;#编译后的cssh1 &#123; color: #333;&#125;h1 a span &#123; color: red;&#125;h1 span &#123; color: #999;&#125; ###3、群组选择器的嵌套1234567891011121314151617181920#scss.main&#123; h1,h2&#123;font-size: 20px;&#125; a&#123; color: red; span&#123; font-size: 16px; &#125; &#125;&#125;#编译后的css.main h1, .main h2 &#123; font-size: 20px;&#125;.main a &#123; color: red; &#125; .main a span &#123; font-size: 16px; &#125; 嵌套-属性嵌套 12345678910111213141516171819202122232425类似于font,border,margin,padding#scss.main&#123; border:&#123; top:1px solid #444;left:1px solid #000; &#125; margin: &#123; top:25px;left:36px;right: 65px;bottom: 23px; &#125; padding: &#123; top: 2px;left: 26px;right: 12px;bottom: 28px; &#125;&#125;#编辑后的css.main &#123; border-top: 1px solid #444; border-left: 1px solid #000; margin-top: 25px; margin-left: 36px; margin-right: 65px; margin-bottom: 23px; padding-top: 2px; padding-left: 26px; padding-right: 12px; padding-bottom: 28px; &#125; 子组合选择器和同层组合选择器：&gt;、+和~ 123456789101112//选择header下面所有的h1元素header h1&#123;font-size: 14px;&#125;//选择header的第一个h1直接子元素header &gt; h1&#123;font-size: 16px&#125;+是同层相邻组合选择器//选择header后紧跟着的p元素header + p&#123;font-size: 18px;&#125;同层全体组合选择器~//选择所有跟在header后的同层header元素header ~ header&#123;font-size: 20px;&#125; ###4、导入Sass文件 12345如果我现在有一个color.scss的配置文件，需要引入到style.scss@import &quot;color&quot;;在style里面也可以使用color.scss的变量#sys-color是color.scss的变量header h1&#123;font-size: 14px;color: $sys-color&#125; 嵌套导入1234567891011121314#color.scss文件内容h1&#123; font-size: 14px; color: #333;&#125;#style.scss引入.container&#123;@import &quot;color&quot;&#125;#编译后的css.container h1 &#123; font-size: 14px; color: #333;&#125; ###5、混合器的使用通常网站会有很多重复的代码存在，比如圆角，或者按钮的css,为了避免写重复的代码，所以我们可以选择用混合器 混合器使用@mixin标识符定义 123456789101112131415161718192021#定义混合器@mixin borderRadius &#123; border-radius: 5px; -webkit-border-radius；5px； -moz-border-radius:5px;&#125;#通过@include来使用这个混合器h1&#123; font-size: 28px;color: #333; @include borderRadius;&#125;#编译后的cssh1 &#123; font-size: 28px; color: #333; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px;&#125; 混合器中的css规则 123456789101112131415161718192021222324252627282930#scss@mixin con-art &#123; margin: 20px; h1&#123; font-size: 16px;color: #666; &#125; h2&#123; font-size: 14px;color: #444; &#125;&#125;footer&#123; font-size: 12px; font-weight: 500; @include con-art;&#125;#编译后的cssfooter &#123; font-size: 12px; font-weight: 500; margin: 20px;&#125;footer h1 &#123; font-size: 16px; color: #666;&#125;footer h2 &#123; font-size: 14px; color: #444;&#125; 混合器传参混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。类似js的function 12345678910111213141516171819//定义可传参数混合器@mixin border-radius($size)&#123; border-radius:$size; -webkit-border-radius:$size; -moz-border-radius:$size;&#125;h1&#123; font-size: 28px;color: #333; @include border-radius(10px);&#125;#编译后的cssh1 &#123; font-size: 28px; color: #333; border-radius: 10px; -webkit-border-radius: 10px; -moz-border-radius: 10px;&#125; 混合器默认参数值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@mixin link-color($def,$hover:$def,$visited:&quot;#365896&quot;) &#123; a&#123;color: $def&#125; &amp;:hover&#123;color: $hover&#125; &amp;:visited&#123;color: $visited&#125;&#125;h1 a&#123; @include link-color(red);&#125;h2 a&#123; @include link-color(red,#555);&#125;h3 a&#123; @include link-color(red,#555,#333);&#125;#编译后的cssh1 a a &#123; color: red; &#125;h1 a:hover &#123; color: red;&#125;h1 a:visited &#123; color: &quot;#365896&quot;; &#125;h2 a a &#123; color: red;&#125;h2 a:hover &#123; color: #555; &#125;h2 a:visited &#123; color: &quot;#365896&quot;;&#125;h3 a a &#123; color: red;&#125;h3 a:hover &#123; color: #555;&#125;h3 a:visited &#123; color: #333;&#125; 复杂的混合器（混合宏-声明混合宏） 123456789101112131415161718192021222324252627282930313233343536373839404142#特别的参数“…”,当混合宏传的参数过多之时，可以使用参数来替代#scss@mixin prefixer($name,$shadow) &#123; @if($name==&apos;border-radius&apos;)&#123; border-radius: $shadow; &#125; @else if($name==&apos;box-shadow&apos;)&#123; box-shadow:$shadow; &#125;&#125;@mixin box-shadow($shadow...) &#123; @if length($shadow) &gt;= 1 &#123; @include prefixer(box-shadow, $shadow); &#125; @else&#123; $shadow:0 0 4px rgba(0,0,0,.3); @include prefixer(box-shadow, $shadow); &#125;&#125;p&#123; font-size: 26px;font-weight: bold; @include box-shadow(0,0,2,#333); font-style:normal;&#125;p.hp&#123; font-size: 26px;font-weight: bold; @include box-shadow(); font-style:normal;&#125;#编译后的cssp &#123; font-size: 26px; font-weight: bold; box-shadow: 0, 0, 2, #333; font-style: normal; &#125;p.hp &#123; font-size: 26px; font-weight: bold; box-shadow: 0 0 4px rgba(0, 0, 0, 0.3); font-style: normal; &#125; 使用选择器继承来精简CSS使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式，则使用@extend 123456789101112131415161718#scss.max-error&#123; font-size: 16px; color: #999;&#125;h1&#123; @extend .max-error; font-weight: 500;&#125;#编译后的css.max-error, h1 &#123; font-size: 16px; color: #999; &#125;h1 &#123; font-weight: 500; &#125; ###6、占位符 %placeholderSass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id与 class 选择器写法相似，只是 #或.替换成了%。必须通过@extend指令调用，当占位符选择器单独使用时（未通过 @extend调用），不会编译到 CSS 文件中。123456789101112131415161718#scss 声明%变量%padTop5&#123; padding-top: 5px;&#125;%padBot5&#123; padding-bottom: 5px;&#125;.ulo&#123; @extend %padTop5; @extend %padBot5;&#125;#编译后的css.ulo &#123; padding-top: 5px; &#125;.ulo &#123; padding-bottom: 5px; &#125;缺点就是生成的css里面无法合并 ###7、SassScript以及运算在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。通过interpolation（插值），SassScript 甚至可以生成选择器或属性名。 数据类型 (Data Types) 123456789101112Sass 和 JavaScript 语言类似，也具有自己的数据类型，在 Sass 中包含以下几种数据类型：- 数字: 如，1、 2、 13、 10px；- 字符串：有引号字符串或无引号字符串，如，&quot;foo&quot;、 &apos;bar&apos;、 baz；- 颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)；- 布尔型：如，true、 false；- 空值：如，null；- 值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif。#SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。#然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。 sass字符串 12345678910111213141516SassScript 支持 CSS 的两种字符串类型：#有引号字符串 (quoted strings)，如 &quot;Lucida Grande&quot; 、&apos;http://baidu.com&apos;；#无引号字符串 (unquoted strings)，如 sans-serifbold。#scss@mixin strings($color)&#123; body.cesj #&#123;$color&#125;:after&#123; content: &quot;welcome,nihao!&quot; &#125;&#125;@include strings(&quot;h1&quot;);#编译后的结果body.cesj h1:after &#123; content: &quot;welcome,nihao!&quot;; &#125;#ps:#&#123;$color&#125; 插入方法，后面会有 sass数组 (Lists)数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。 1234margin: 10px 15px 0 0font-face: Helvetica, Arial, sans-serif#独立的值也被视为值列表——只包含一个值的值列表。font-size:14px 12345678910111213数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。#scss.ul-li&#123; margin: 0px 5px 7px 9px; padding: (0px 5px)(7px 9px);&#125;#编译后的css.ul-li &#123; margin: 0px 5px 7px 9px; padding: 0px 5px 7px 9px; &#125; 数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth函数可以直接访问数组中的某一项；join函数可以将多个数组连接在一起；append函数可以在数组中添加新值；@each指令能够遍历数组中的每一项。 ###8、sass 运算SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)如果必要会在不同单位间转换值。 加法运算 1234567891011121314#scss in即inch,是英寸的意思html&#123; width: 20px + 8in;&#125;#编译后的csshtml &#123; width: 788px; &#125;ps：对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示html&#123; width: 20px + 1em;&#125;#Error: Incompatible units: &apos;em&apos; and &apos;px&apos;.in mm cm pt pc px都可以 减法运算 1234567#scsshtml&#123; width: 800px - 20px;&#125;#编译后的csshtml &#123; width: 780px; &#125; 除法运算 12345678910111213141516171819202122232425262728如果按照下面的写是不对的，结果不会进行除法运算html&#123; width: 20px / 2;&#125;需要加上（）进行运算html&#123; width: (20px / 2);&#125;#“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。html&#123; width: 100px / 2 + 2in;&#125;#编译后的csshtml &#123; width: 242px; &#125;也可以通过变量进行除法运算$width:500px;html&#123; width: $width / 2 + 2in;&#125;#编译后的csshtml &#123; width: 442px; &#125; 乘法运算 12345678#scss Error: 40px*px isn&apos;t a valid CSS value.html&#123; width: 20px * 2px;&#125;#正确方式html&#123; width: 20px * 2;&#125; 颜色运算所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。 12345678910111213141516html&#123; color: #010203 + #040506;&#125;计算方式：1+4=5 2+6 = 7 3+6 = 9#编译后的csshtml &#123; color: #050709; &#125;html &#123; color: #010203 * 2;&#125;#编译后的csshtml &#123; color: #020406; &#125; 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 1234567#scsshtml&#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125;#编译后的csshtml &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify或 transparentize两个函数进行调整。 12345678910#scss$translucent-red: rgba(255, 0, 0, 0.5);html&#123; color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25);&#125;#编译后的csshtml &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; 字符串运算 (String Operations)+可用于连接字符串1234567#scsshtml&#123; cursor: e + -resize;&#125;#编译后的csshtml &#123; cursor: e-resize; &#125; 123456789#scsshtml&#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125;#编译后的csshtml &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 1234567#scsshtml&#123; margin: 3px + 4px auto;&#125;#编译后的csshtml &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用#{}插值语句可以添加动态的值：1234567#scsshtml&#123; content: &quot;I ate #&#123;5 + 10&#125; pies!&quot;;&#125;#编译后的csshtml &#123; content: &quot;I ate 15 pies!&quot;; &#125; 布尔运算 (Boolean Operations)SassScript 支持布尔值的 and, or, 和 not 运算。12345678910111213and运算#scss$age:10;html&#123; @if ($age &gt; 10 and $age &lt; 25) &#123; color: green; &#125;@else&#123; color:red; &#125;&#125;#编译后的csshtml &#123; color: red; &#125; or 运算123456789101112#scss$age:15;html&#123; @if ($age&lt;20 or $age&gt;5) &#123; color: green; &#125;@else&#123; color:red; &#125;&#125;#编译后的csshtml &#123; color: green; &#125; not 运算123456789101112#scss$age:10;html&#123; @if ($age not 25) &#123; color: green; &#125;@else&#123; color:red; &#125;&#125;#编译后的csshtml &#123; color: green; &#125; 插值语句123456789#scss$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125;#编译后的cssp.foo &#123; border-color: blue; &#125; 先到此吧，后续还会继续更新]]></content>
      <categories>
        <category>sass</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干货，大神的javascript思维导图，赶紧收藏吧！！]]></title>
    <url>%2F2017%2F08%2F23%2Fsiweidaotujs%2F</url>
    <content type="text"><![CDATA[废话不说，直接上图,文件打包下载路径：去下载 文件打包下载路径：去下载]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之选择器]]></title>
    <url>%2F2017%2F03%2F12%2Fcss%2Fcss-xzq%2F</url>
    <content type="text"><![CDATA[CSS1选择器 .class 选择 class=”info” 的所有元素.info{background:red;} #id 选择 id=”nav” 的所有元素 1#nav &#123;background:red;&#125; element 选择所有的element(a、p…)元素 element,element 选择多个所有element(a、p…)元素 :link 选择所有未被访问的链接 :visited 选择所有已被访问的链接 :active 选择活动链接 :hover 选择鼠标指针位于其上的链接 :first-letter 选择每个element元素的首字母 :first-line 选择每个element元素的首行 CSS2选择器 * 选择所有元素 ps: {} element &gt; element2 选择父元素为 元素的所有 元素。 element+element2 选择element元素后面所有的element2元素 :focus 选择获得焦点的 input 元素 :first-child 选择属于父元素的第一个子元素的每个 元素 element:before 在每个element元素的内容之前插入内容 element:after 在每个element元素的内容之后插入内容 element:lang[it] 选择带有以 “it” 开头的 lang 属性值的每个element元素 属性选择器 属性选择器 描述 E[att] 选择匹配元素E,并且元素定义了att即可 (CSS2) E[att = “val”] 选择匹配元素E,并且元素定义了att，其属性值等于val (CSS2) E[att~ = “val”] 选择匹配元素E,并且元素定义了att，其属性包含val这个词汇 (CSS2) E[att&#124; = “val”] 选择匹配元素E,并且元素定义了att，其属性以val开头的（该值必须是整个单词）(CSS2) E[att^ = “val”] 选择匹配元素E,并且元素定义了属性att,其属性值以val 开头的任何字符串 (CSS3) E[att$ = “val”] 选择匹配元素E,并且元素定义了属性att,其属性值以val 结尾的任何字符串 (CSS3) E[att* = “val”] 选择匹配元素E,并且E元素定义了属性att,其属性值任意位置包含了val。（字符串与属性值中的任意位置相匹配）(CSS3) CSS3选择器 element ~element2 选择前面有element元素的每个element2元素 :root :root 选择器匹配文档根元素。在 HTML 中，根元素始终是 html 元素。 123:root&#123;background:#000;&#125;等价于html&#123;background:#000;&#125; not :not(selector) 选择器匹配非指定元素/选择器的每个元素。 123:not(p)&#123;background:#000&#125;;// 非p元素的设置input:not([type=&quot;submit&quot;])&#123;background:#000;&#125;// input并且type不等于submit的元素 empty 选择器匹配没有子元素（包括文本节点）的每个元素 target 选择当前活动的 # 元素,用来匹配文档(页面)的url的某个标志符的目标元素 12345&lt;a href=&quot;#brank&quot;&gt;测试&lt;/a&gt;#brank:target&#123; background: #000;&#125; :enabled 选择每个启用的元素（有些元素是可以使用此属性:ps: input） :disabled 选择每个禁用的元素（有些元素是可以使用此属性ps:input） :checked 选择每个被选中的元素(input) :selection 选择被用户选取的元素部分,用来匹配突出显示的文本(用鼠标选择文本时的文本) 注意：121、IE9+、Opera、Google Chrome 以及 Safari 中支持 ::selection 选择器。2、Firefox 支持替代的 ::-moz-selection。 :read-only 选择器用来指定处于只读状态元素的样式 :read-write 选择器对元素处于非只读状态时的样式 :last-child 选择属于其父元素最后一个子元素 :nth-child(n) 选择器用来定位某个父元素的一个或多个特定的子元素 :nth-child(n)选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素 :nth-last-child(n) 从某父元素的最后一个子元素开始计算，来选择特定的元素 :first-of-type 用来定位一个父元素下的某个类型的第一个子元素 ele:nth-of-type(n) 选择属于其父元素第n个ele元素的每个ele元素 :last-of-type 父元素下的某个类型的最后一个子元素 :nth-last-of-type(n) 选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始 :only-child 匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素 :only-of-type 选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素 更多详细w3school]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
</search>
